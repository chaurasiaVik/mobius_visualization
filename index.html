<!DOCTYPE html>
<html>

<head>
  <meta http-equiv='Content-Type' content='text/html' charset='utf-8' />
  <title>M&ouml;bius bands</title>
  <link href='utils/3M_favicon.png' rel='icon'>
  <link rel='stylesheet' type='text/css' href='utils/kN.css'>
  <link rel="stylesheet" href='utils/shepherd.css'>
  <script src='utils/babylon.custom.js'></script>

  <script src='utils/util.js'></script>
  <script src='utils/tetToggler.js'></script>
  <script src='utils/global_variable.js'></script>
  <script src='utils/kN3.js'></script>
  <script src='utils/data_lower_envelope.js'></script>

  <script src='utils/chart.umd.js' defer></script>
  <script src='utils/mathjax_min.js' defer></script>
  <!-- <script src='utils/animated-cursor.js' defer></script> -->

  <script src="https://unpkg.com/animated-cursor@1.1.1/dist/index.umd.js"></script>

  <!-- Shepherd.js JavaScript -->
  <script src='utils/shepherd.js'></script>
  <!-- <script src='utils/tour.js'></script> -->

</head>

<body>

  <div class="cursor"></div>
  <script>
    const cursor = document.querySelector('.cursor');

    document.addEventListener('mousemove', e => {
      cursor.setAttribute("style", "top: " + (e.pageY - 10) + "px; left: " + (e.pageX - 10) + "px;")
    })

    document.addEventListener('click', () => {
      cursor.classList.add("expand");

      setTimeout(() => {
        cursor.classList.remove("expand");
      }, 500)
    })

  </script>

  <div class='leftbar'>

    <svg width='200' height='110' viewBox='-100 -55 200 110' style='margin-top:10px'>
      <g class='touchElement glow-effect' id='buttNumOfTetMinus'>
        <title>decrease the number n of half twists of the optimal band with n fold rotational symmetry</title>
        <circle cx='-62' cy='10' r='34' /> <!-- Modified cy here -->
        <polygon points='-80 7 -80 13 -44 13 -44 7' fill='#fff' /> <!-- Adjusted y values in points -->
      </g>
      <g class='touchElement glow-effect' id='buttNumOfTetPlus'>
        <title>increase the number n of half twists of the optimal band with n fold rotational symmetry</title>
        <circle cx='62' cy='10' r='34' /> <!-- Modified cy here -->
        <polygon points='80 7 80 13 65 13 65 28 59 28 59 13 44 13 44 7 59 7 59 -8 65 -8 65 7' fill='#fff' />
        <!-- Adjusted y values in points -->
      </g>
      <g class="textElement" id='infoTet'>
        <text y='-40'>number of half twists</text>
        <text id='infoNumOfTet' y='16'>3</text>
      </g>
    </svg>


    <svg id='tetTogStar ' class='tetTogStar glow-effect' width='0 ' height='0' viewBox='-600 -600 1200 1200'></svg>

    <svg id='playSVG' width='200' height='200' viewBox='-60 -60 120 120' style='margin-top:10px'>
      <g class='touchElement glow-effect' id='buttPlayPause'>
        <title> click to play the everting motion</title>
        <circle cx='0' cy='0' r='20' />
        <polygon id='playPausePoly' points='-7 -10 -7 10 13 0' fill='#fff' />
      </g>
      <g class='touchElement  ' id='clockRing'>
        <title> drag to evert the band</title>
        <circle cx='0' cy='0' r='40' fill='none' stroke='#555' stroke-width='26' />
        <circle id='clockHand' r='10' fill='#fff' />
      </g>
    </svg>

    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" style="height:0; width:0; position:absolute;">
      <defs>
        <filter id="colorful-glow">
          <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" />
          <feOffset in="blur" dx="0" dy="0" result="offsetBlur" />
          <feFlood flood-color="#FF7300" result="flood" />
          <feComposite in="flood" in2="offsetBlur" operator="in" result="colorBlur"/>
          <feMerge>
            <feMergeNode in="colorBlur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
    </svg>
    

    
    <svg id='speedSlider' class='slider glow-effect' width='200' height='100' viewBox='-100 -25 200 50'>
      <title> slide to change the speed of eversion</title>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg>

    <svg id='hingeLengthSlider' class='slider glow-effect' width='200' height='100' viewBox='-100 -25 200 50'>
      <title> slide to change the width of the band</title>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg>
    <br>
    <br>
    <g class="textElement">
      <text> view angle </text>
    </g>
    <button class='button' id='buttAlignAxis' title='align the view with the axis of symmetry'> align axis </button>
    <button class='button' id='buttAlignPlane' title='align the view with the best fit plane'> align plane </button>
  </div>

  <div class='rightbar'>
    <button class='button' id='buttFullScreen' title='enable full screen'> full screen </button>
    <br>
    <br>
    <button class='button' id='buttShowMid' title='path traced by a point on the midline
    of the band  during the everting motion'> eversion path </button>
    <button class='button' id='buttShowUnit' title='show 1/n th of the band with n half twists '> show unit </button>
    <!-- <button class='button' id='buttShowAxis'> show axis </button> -->
    <br>
    <br>
    <!-- <g class="textElement">

      <text> physics </text>
    </g> -->

    <button class='button' id="buttShowEnergy"
      title='dimensionless torsion of the midline versus dimensionless bending energy of the stable bands. click on the plot to change the torsion'>
      bending energy</button>
    <button class='button' id="buttShowKappa"
      title='curvature of the midline. the rainbow color corresponds to the arclength. the n red dots are evenly spaced points on the band with n half twists'>
      curvature</button>

    <br>
    <br>
    <g class="textElement">

      <text> colors </text>
    </g>
    <button class='button' id='buttColor1' title='ranbow color scheme for the surface of the band'> rainbow </button>
    <button class='button' id='buttColor2' title='two faces of the band colored with white and red'> digital </button>
    <!-- <button class='button' id='buttColor3'> M&ouml;bius rainbow 3 </button>
    <button class='button' id='buttColor4'> digital </button>
    <button class='button' id='buttColor5'> M&ouml;bius BRW 3 </button> -->


    <button class='button' id="backgroundButton"
      title='change the background color for the best visibility using picker on the left-top'>background Color</button>
    <input type="color" id="colorPicker" style="display: none;">

    <!-- <input class="jscolor" value="ab2567" data-jscolor="{format:'rgba', position:'right', width:181, height:101}"> -->


  </div>

  <div class="container">
    <div class="content">
      <canvas id='renderCanvas' touch-action='none'></canvas>
      <img src='utils/dragon_oist.svg' style='height:40px;position:absolute;left:0;bottom:0;margin:10px'>
      <img src='utils/3M_white.svg' style='height:40px;position:absolute;right:0;bottom:0;margin:10px'>
    </div>
  </div>
  <div class="contentE">
    <canvas id='renderCanvasE' touch-action='none'></canvas>
    <!-- <canvas id="magnifier"></canvas> -->
  </div>
  <div class="contentK">
    <canvas id='renderCanvasK' touch-action='none'></canvas>
  </div>


  </div>

  <div id="animatedCursor"></div>


  <div id="tourModal" class="modal-backdrop">
    <div class="modal-content">
      <h2>Welcome!</h2>
      <p>Would you like a guided tour of the application?</p>
      <button id="startTourBtn" class="modal-button">Start Tour</button>
      <button id="dismissTourBtn" class="modal-button">No Thanks</button>
      <!-- <p> Press c on the keyboard to interrupt the tour.</p> -->
    </div>
  </div>



  <script>

    colEnergy = colEnergy.map(rgb => rgb.map(val => Math.round(val * 255)));
    var contentE = document.querySelector('.contentE');
    var content = document.querySelector('.content');
    var contentK = document.querySelector('.contentK');
    var contentKWidth = contentK.clientWidth;
    var nChanged = new Event('nChanged'); // triggered by plus/minus buttons
    var energyChanged = new Event('energyChanged'); // triggered by plus/minus buttons
    // var N = 240
    var nu_i;
    var plotClicked;


    var yData = Array.from(energy).concat();
    len_ydata = yData.length;
    var xData = linspace(8.095, 85.4, len_ydata);

    'use strict';


    if (document.documentMode || /Edge/.test(navigator.userAgent)) {
      alert('MICROSOFT ALARM: You are using strange software which may lead to unexpected behavior of the website. Please use a reasonable 21st century browser, like, for example: Chrome, Firefox, Opera, Safari,...');
    }


    // adding default-visible class to the left and right bar so that they are visible when the page is loaded

    document.addEventListener('DOMContentLoaded', function () {


      const elements = document.querySelectorAll('.leftbar .touchElement, .leftbar .slider, .rightbar .touchElement, .rightbar .slider, .leftbar .button, .rightbar .button, .leftbar .textElement, .rightbar .textElement');
      elements.forEach(el => el.classList.add('default-visible'));

      setTimeout(() => {
        elements.forEach(el => el.classList.remove('default-visible'));
      }, 15000);
    });



    window.addEventListener('DOMContentLoaded', function () {

      // get the canvas DOM element
      var canvas = ebID('renderCanvas');

      // load the 3D engine
      var engine = new BABYLON.Engine(canvas, true);

      // createScene function that creates and return the scene
      var createScene = function () {
        // create a basic BJS Scene object
        var scene = new BABYLON.Scene(engine);
        scene.useRightHandedSystem = true;
        scene.clearColor = new BABYLON.Color3(0.3254901960784314, 0.396078431372549, 0.3686274509803922);
        // camera Math.PI
        var camera = new BABYLON.ArcRotateCamera('ArcRotateCamera', Math.PI, 0, 1.2, new BABYLON.Vector3.Zero(), scene);
        camera.lowerRadiusLimit = .1;
        camera.upperRadiusLimit = 100;
        camera.wheelPrecision = 100;
        camera.pinchPrecision = 200;
        scene.activeCamera.panningSensibility = 0;
        camera.alpha = 6.185710546084945;
        camera.beta = 1.0989063024750556;
        camera.radius = 3;
        ///////////////////////////////////////////////////////////////////////////////////

        var light = new BABYLON.SpotLight('spotLight', new BABYLON.Vector3(-.0, 1.5, 0), new BABYLON.Vector3(1, 1, 1), Math.PI / 2, .1, scene);
        light.shadowIntensity = 1.0;
        light.shadowBlur = 4;

        // Set the target of the light to be the camera position
        light.setDirectionToTarget(camera.position);
        // light.parent = camera;

        var white = new BABYLON.StandardMaterial('texture1', scene);
        var cyan = new BABYLON.StandardMaterial('texture1', scene);
        var yellow = new BABYLON.StandardMaterial('texture1', scene);
        var red = new BABYLON.StandardMaterial('texture1', scene);
        var trans = new BABYLON.StandardMaterial('texture1', scene);
        white.diffuseColor = new BABYLON.Color3(1, 1, 1);
        cyan.diffuseColor = new BABYLON.Color3(0, 1, 1);
        yellow.diffuseColor = new BABYLON.Color3(1, 1, 0);
        red.diffuseColor = new BABYLON.Color3(1, 0, 0);
        //cyan.wireframe = true;
        trans.alpha = 0.7;

        var bandMat = new BABYLON.StandardMaterial('texture1', scene);

        bandMat.diffuseColor = new BABYLON.Color3(1, 1, 0);


        // var ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 4, height: 4 }, scene);
        // var groundMaterial = new BABYLON.StandardMaterial('groundMaterial', scene);
        // groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2); // Set a dark color for the ground

        // groundMaterial.specularColor = new BABYLON.Color3(1, 1, 1);; // Disable specular highlights

        // ground.position = new BABYLON.Vector3(0, -.7, 0);

        // ground.material = groundMaterial;


        // Create a new standard material 'glass' 
        var glass = new BABYLON.StandardMaterial("glass", scene);

        // Make it transparent
        glass.alpha = 0.045;
        // Give it a high specular power for glossiness
        glass.specularPower = 100;
        // Give it a low diffusivity so it doesn't scatter light
        glass.diffuseColor = new BABYLON.Color3(1, 1, 1, .1);
        // Set its index of refraction to something like glass
        glass.indexOfRefraction = 1.52;

        //scene.clearColor = new BABYLON.Color3(0, 0, 0);
        //scene.createDefaultSkybox(backgroundTexture, true);



        ///////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////




        // Set the material of the arrow



        var golf = [];



        init_parameters(1);
        data_t0(1);



        var midlineMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        midlineMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        midlineMaterial.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);

        var optionsMidline = [];
        var midline = [];

        // rulings 
        var rulingsMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        rulingsMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        rulingsMaterial.emissiveColor = new BABYLON.Color4(1, 1, 1, 1);

        var optionsRulings = [];
        var rulings = [];



        function midlineInit() {
          // Update the path
          var initialPath = [];
          for (var i = 0; i < N + 1; i++) {
            initialPath.push(new BABYLON.Vector3(0, 0, 0));
          }

          optionsMidline = {
            path: initialPath, //vec3 array,
            radius: 0.004, // set the radius of the tube
            updatable: true
          };
          // Update the tube mesh with the new data
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline, scene);
          midline.material = midlineMaterial;

          // initialize rulings 


          for (var i = 1; i < n + 1; i++) {
            let temp = [];
            temp.push(new BABYLON.Vector3(0, 0, 0));
            temp.push(new BABYLON.Vector3(0, 0, 0));

            optionsRulings = {
              path: temp, //vec3 array,
              radius: 0.01, // set the radius of the tube
              updatable: true
            };

            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings, scene);
            rulings[i].material = rulingsMaterial;


          };

        };
        midlineInit();




        function k_to_t(k) {
          return Math.round(k * N / (2 * Math.PI));
        };
        var t;



        var eversionPlay = new Event('eversionPlay'); // triggered by plus/minus buttons

        var vertexData = [];
        var vertexDataBack = [];
        var band = new BABYLON.Mesh('custom', scene);
        var bandBack = new BABYLON.Mesh('custom', scene);



        function updateBandMesh(k, hingeLength) {
          t = k_to_t(k);
          let temp = fourierExpansion(N, t, hingeLength);
          var v = temp[0];

          // updating curvature 
          kappa = temp[1].concat();
          document.body.dispatchEvent(eversionPlay);


          if (showKappa == true) {
            if (chartK != null) {
              destroyChart(chartK);
            }
            createchartK(kappa);
          }





          // N = 105;
          var pos = [];
          var pathMidline = [];
          var indices = [];
          var indicesBack = [];
          var colors = [];
          var colorsBack = [];

          for (var i = 1; i < N + 1; i++) {
            var v1 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
            var v2 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];



            pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

            // surface 

            pos.push(v1[0], v1[1], v1[2]);
            pos.push(v2[0], v2[1], v2[2]);

            if (colorScheme == 1) {
              var c1 = jet(i - 1);

              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            } else {
              colors.push(1, 1, 1, 1);
              colors.push(1, 1, 1, 1);
              colorsBack.push(1, 0, 0, 1);
              colorsBack.push(1, 0, 0, 1);
            }

            if (i > 0) {
              indices.push(2 * i - 1, 2 * i, 2 * i - 2);
              indices.push(2 * i, 2 * i - 1, 2 * i + 1);

              indicesBack.push(2 * i, 2 * i - 1, 2 * i - 2);
              indicesBack.push(2 * i - 1, 2 * i, 2 * i + 1);

            };
          };

          //   console.log(pathMidline)
          // Update the tube mesh with the new path
          // Remove the existing tube mesh


          i = 1;
          var v2 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
          var v1 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];

          pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

          pos.push(v1[0], v1[1], v1[2]);
          pos.push(v2[0], v2[1], v2[2]);

          if (colorScheme == 1) {
            var c1 = jet(i - 1);

            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
          } else {
            colors.push(1, 1, 1, 1);
            colors.push(1, 1, 1, 1);
            colorsBack.push(1, 0, 0, 1);
            colorsBack.push(1, 0, 0, 1);
          }

          // indicesBack.push(2*N-1, 1, 0);
          // indicesBack.push(2*N-1, 0, 2*N);

          //   indices.push( 0,2*N-1, 2*N);
          //   indices.push( 1,2*N-1, 0);


          var normals = [];
          BABYLON.VertexData.ComputeNormals(pos, indices, normals);

          var vertexData = new BABYLON.VertexData();
          vertexData.positions = pos;
          vertexData.indices = indices;
          vertexData.normals = normals;
          vertexData.colors = colors;

          vertexData.applyToMesh(band);



          var normalsBack = [];
          BABYLON.VertexData.ComputeNormals(pos, indicesBack, normalsBack);
          vertexDataBack = new BABYLON.VertexData();
          vertexDataBack.positions = pos;
          vertexDataBack.indices = indicesBack;
          vertexDataBack.normals = normalsBack;
          vertexDataBack.colors = colorsBack;

          vertexDataBack.applyToMesh(bandBack);

          ///  surface created 

          /// creating midline 

          // Update
          optionsMidline.path = pathMidline;
          optionsMidline.instance = midline;
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline); //No scene parameter when using instance
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);


          if (showUnit) {
            // Enable vertex alpha for the mesh
            band.hasVertexAlpha = true;
            bandBack.hasVertexAlpha = true;

            // Disable backface culling
            //band.backFaceCulling = false;
            //bandBack.backFaceCulling = false;

            var vertexData = band.getVerticesData(BABYLON.VertexBuffer.ColorKind);
            var vertexDataBack = bandBack.getVerticesData(BABYLON.VertexBuffer.ColorKind);

            // Ensure the vertex buffer is large enough to accommodate the modifications
            if (!vertexData || vertexData.length < 4 * (N + 1)) {
              vertexData = new Float32Array(4 * (N + 1));
            }
            if (!vertexDataBack || vertexDataBack.length < 4 * (N + 1)) {
              vertexDataBack = new Float32Array(4 * (N + 1));
            }

            var ind = Math.round(N / n) + 1;
            for (var i = ind; i < N + 1; i++) {
              var j = 2 * i;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 1;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 2;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 3;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;
            }

            // Update the vertex colors with modified alpha values
            band.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexData);
            bandBack.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexDataBack);


          };




          var ind1 = Math.round(N / (2 * n));

          for (var j = 1; j < golf.length + 1; j++) {
            let l = 2 * j * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            if (golf[j]) {
              golf[j].position = new BABYLON.Vector3((v1[0] + v2[0]) / 2,
                (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2);

            };

          };



          var ind1 = Math.round(N / (2 * n));


          // creating rulings 
          for (var i = 1; i < n + 1; i++) {
            // l =  i * ind1   ;
            l = 2 * i * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            let path = [];
            path.push(new BABYLON.Vector3(v1[0], v1[1], v1[2]));
            path.push(new BABYLON.Vector3(v2[0], v2[1], v2[2]));

            optionsRulings.path = path;
            optionsRulings.instance = rulings[i];
            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings); //No scene parameter when using instance


          };

          // meshDispose(golf) 

        };




        // tube paths /////////////////////////////////////////////////////////////////////

        function createTube(tube, type, hingeLength, color) {
          var ind0 = Math.round(N / (2 * n));
          for (var i = 1; i < n + 1; i++) {
            var ind = 2 * i * ind0 - 2 * ind0 + 1;

            var curve = paths(n, hingeLength, type, ind);
            tube[i] = BABYLON.Mesh.CreateTube('tube', curve, 0.0025, 8, null, null, scene);
            tube[i].material = color;
            golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
              'ico', { radius: 0.03, subdivisions: 8, flat: false, updatable: false }, scene);
            golf[i].material = red;
            updateBandMesh(k, hl);

          }
          // if (type == 2) { // midpoints get golf
          //   for (var i = 1; i < n + 1; ++i) {
          //     golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
          //       'ico', { radius: 0.03, subdivisions: 8, flat: false, updatable: false }, scene);
          //     golf[i].material = color;
          //   }
          // updateBandMesh(k, hl);
          // }
        }


        // plane //////////////////////////////////////////////////////////////////////////

        function enablePlane(bool) {


        }


        // dispose mesh ///////////////////////////////////////////////////////////////////

        function meshDispose(me) {
          var i = 1;
          while (me[i]) {
            me[i].dispose();
            i += 1;
          }
        }



        //#################################################################################
        //#################################################################################

        // change number of tetrahedra ////////////////////////////////////////////////////

        ebID('buttNumOfTetMinus').addEventListener('click', function () {
          if (n > 3) {
            n = n - 2;
            document.body.dispatchEvent(nChanged);
            // document.body.dispatchEvent(nuiChanged);
          }
        });
        ebID('buttNumOfTetPlus').addEventListener('click', function () {
          if (n < 27) {
            n = n + 2;
            document.body.dispatchEvent(nChanged);
            // document.body.dispatchEvent(nuiChanged);
          }
        });


        // show corner/midpoint paths /////////////////////////////////////////////////////

        var showMid = false;

        //#################################################################################
        //#################################################################################





        // document.body.addEventListener('nuiChanged', function (e) {
        //   nuSlider = new Slider('nuSlider', nu_min, nu_max, nu_opt, '&nu;    ', 0, ' ');
        //   ebID('nuSlider').addEventListener('sliderChange', function (e) {
        //     nu_i = parseInt(nuSlider.getValue());
        //      document.body.dispatchEvent(nChanged);
        //     refresh = true;
        //   });

        // }, false);

        /////////////////////////nui changed////////////////////////////

        /////////////////////////n  changed////////////////////////////


        document.body.addEventListener('nChanged', function (e) {
          ebID('infoNumOfTet').innerHTML = n;

          n_to_nui(n)
          // modifying the slider and its limits when n is changed 

          nu_i = nu_opt;

          init_parameters(nu_i)
          data_t0(nu_i);

          midline.dispose();
          meshDispose(rulings);
          midlineInit();


          if (showMid) {
            meshDispose(tubeMid);
            meshDispose(golf);
            createTube(tubeMid, 2, 0.5 * 3, yellow);
          }

          updateBandMesh(k, hl);

          refresh = true;
        }, false);

        //plotClicked = new CustomEvent('plotClicked', { detail: { nu_i:nu_i,n:n } });

        function magnify(canvasId, zoom) {
          var canvas = document.getElementById(canvasId);
          var magnifier = document.getElementById("magnifier");
          var magnifierCtx = magnifier.getContext("2d");
          var magnifierDiameter = magnifier.width; // Assuming width and height are the same
          var magnifierRadius = magnifierDiameter / 2;

          function moveMagnifier(e) {
            var canvasRect = canvas.getBoundingClientRect();
            var mouseX = e.clientX - canvasRect.left;
            var mouseY = e.clientY - canvasRect.top;

            // Adjust magnifier position to be centered on cursor
            var magnifierX = e.pageX - magnifierRadius;
            var magnifierY = e.pageY - magnifierRadius;

            // Position the magnifier
            magnifier.style.left = magnifierX - 55 + "px";
            magnifier.style.top = magnifierY + 96 + "px";

            // Clear previous content
            magnifierCtx.clearRect(0, 0, magnifierDiameter, magnifierDiameter);

            // Calculate the zoomed area
            magnifierCtx.drawImage(canvas,
              mouseX * (canvas.width / canvas.offsetWidth) - magnifierRadius / zoom,
              mouseY * (canvas.height / canvas.offsetHeight) - magnifierRadius / zoom,
              magnifierDiameter / zoom, magnifierDiameter / zoom,
              0, 0, magnifierDiameter, magnifierDiameter);
          }

          canvas.addEventListener("mousemove", moveMagnifier);
        }

        // Initialize the magnifier
        //magnify("renderCanvasE", 3); // Adjust the zoom level as needed




// Update the canvas position when the window is resized
var canvasPosition = document.getElementById('renderCanvasE').getBoundingClientRect();
window.addEventListener('resize', debounce(function () {
    canvasPosition = document.getElementById('renderCanvasE').getBoundingClientRect();
}, 250));

// Event listener for the click on renderCanvasE
document.getElementById('renderCanvasE').addEventListener('click', function (evt) {
    // Calculate the click position relative to the canvas
    const clickX = evt.clientX - canvasPosition.left;
    const clickY = evt.clientY - canvasPosition.top;

    console.log("Canvas clicked at: ", clickX, clickY);

    // Chart.js method to find the nearest point
    var points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, true);
    if (points.length) {
        var nearestPoint = points[0];
        const dataPoint = chart.data.datasets[nearestPoint.datasetIndex].data[nearestPoint.index];
        nu_i = getIndexFromLinspace(dataPoint.x);
        nui_to_n(nu_i);

        plotClicked = new CustomEvent('plotClicked', { detail: { nu_i: nu_i, n: n } });
        document.body.dispatchEvent(plotClicked);

        refresh = true;
    }
});

function debounce(func, wait) {
    var timeout;
    return function () {
        var context = this, args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(function () {
            func.apply(context, args);
        }, wait);
    };
}

 

// Debounce function to limit the rate at which a function can fire
function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}



        document.body.addEventListener('plotClicked', function (e) {

          n = e.detail.n;
          nu_i = e.detail.nu_i;


          ebID('infoNumOfTet').innerHTML = n;


          init_parameters(nu_i);
          data_t0(nu_i);
          midline.dispose();
          meshDispose(rulings);
          midlineInit();

          if (showMid) {
            meshDispose(tubeMid);
            meshDispose(golf);
            createTube(tubeMid, 2, 0.5 * 3, yellow);
          }

          updateBandMesh(k, hl);
          refresh = true;
        }, false);

        // toggle tetrahedra //////////////////////////////////////////////////////////////

        var tetToggled = new Event('tetToggled'); // triggered by tetTogStar
        document.body.addEventListener('tetToggled', function (e) { refresh = true; }, false);

        var tetTogStar = new TetTogStar('tetTogStar', nMax, tetToggled);

        // play controller ////////////////////////////////////////////////////////////////

        var svg = ebID('playSVG');
        var pt = svg.createSVGPoint();
        var dragging = false;
        var clockRing = ebID('clockRing');
        clockRing.addEventListener('mousedown', startDragMouse, false);
        clockRing.addEventListener('touchstart', startDragTouch, false);
        window.addEventListener('mousemove', dragMouse, false);
        window.addEventListener('touchmove', dragTouch, false);
        window.addEventListener('mouseup', stopDrag, false);
        window.addEventListener('touchend', stopDrag, false);
        function startDragMouse(ev) {
          dragging = true;
          if (play) { playIt() };
          dragMouse(ev);
          clockRing.style.opacity = 1;
        }
        function startDragTouch(ev) {
          dragging = true;
          if (play) { playIt() };
          dragTouch(ev);
          clockRing.style.opacity = 1;
        }
        function dragMouse(ev) {
          if (dragging) {
            pt.x = ev.clientX;
            pt.y = ev.clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateBandMesh(k, hl);
            refresh = true;
          }
        }
        function dragTouch(ev) {
          if (dragging) {
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateBandMesh(k, hl);
            refresh = true;
          }
        }
        function stopDrag() {
          dragging = false;
          clockRing.style.opacity = '';
        }
        function playIt() {
          play = !play;
          if (!play) {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 13 0');
          }
          else {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 -2 10 -2 -10 2 -10 2 10 7 10 7 -10 -7 -10');
          }
        };
        ebID('buttPlayPause').addEventListener('click', playIt, false);
        document.addEventListener('keydown', function (e) { if (e.keyCode == '32') playIt(); }); // space key play

        // speed control //////////////////////////////////////////////////////////////////

        var speedSlider = new Slider('speedSlider', 4, 100, 20, 'speed ', 0, '%');
        ebID('speedSlider').addEventListener('sliderChange', function () {
          speedy = speedSlider.getValue() / 2000 / n ** .2;
        });

        // change width/length ////////////////////////////////////////////////////////////

        var hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 20, 'width', 0, '%');
        ebID('hingeLengthSlider').addEventListener('sliderChange', function () {
          hl = hingeLengthSlider.getValue() / 100.0;
          if (!play) updateBandMesh(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })


        ///  modifying sliders during the guiding tour 
        ebID('speedSlider').addEventListener('tourSpeed', function () {
          speedSlider = new Slider('speedSlider', 4, 100, 40, 'speed ', 0, '%');
          speedy = 40 / 2000 / n ** .2;
        });

        ebID('speedSlider').addEventListener('tourSpeedBack', function () {
          speedSlider = new Slider('speedSlider', 4, 100, 20, 'speed ', 0, '%');
          speedy = 20 / 2000 / n ** .2;
        });


        ebID('hingeLengthSlider').addEventListener('tourWidth', function () {
          hl = 0.4;
          hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 40, 'width', 0, '%');

          if (!play) updateBandMesh(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })
        ebID('hingeLengthSlider').addEventListener('tourWidthBack', function () {
          hl = 0.2;
          hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 20, 'width', 0, '%');

          if (!play) updateBandMesh(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })

        ////////////////////////////////////////////////////////////////

        // toggle full screen /////////////////////////////////////////////////////////////

        // var ortho = false;
        var fullScreen = false;
        ebID('buttFullScreen').addEventListener('click', function () {
          fullScreen = !fullScreen;
          buttonSwitchColor(ebID('buttFullScreen'), fullScreen);
          toggleFullScreen();
          // ortho = !ortho;
          // if ( ortho ) camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
          // else camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
        });


        // show axis/plane ////////////////////////////////////////////////////////////////





        var showUnit = false;
        ebID('buttShowUnit').addEventListener('click', function () {
          showUnit = !showUnit;
          buttonSwitchColor(ebID('buttShowUnit'), showUnit);





          refresh = true;
        });

        // align to plane/axis ////////////////////////////////////////////////////////////
        var alignPlane = false;
        ebID('buttAlignPlane').addEventListener('click', function () {
          alignPlane = !alignPlane;
          //  buttonSwitchColor(ebID('buttAlignPlane' ), alignPlane);
          camera.alpha = Math.PI;
          camera.beta = Math.PI / 2;
          if (!play) k = 0;
          refresh = true;
        });
        var alignAxis = false;
        ebID('buttAlignAxis').addEventListener('click', function () {
          alignAxis = !alignAxis;
          // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = Math.PI;
          camera.beta = 0;
          if (!play) k = 0;
          refresh = true;
        });

        // changing the camera angle during the tour 
        ebID('renderCanvas').addEventListener('tourCamera', function (event) {
          console.log("enetered rotate camera")
          // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = event.detail.alpha;
          camera.beta = event.detail.beta;
          if (!play) k = 0;
          refresh = true;
        });

        // change surface colors //////////////////////////////////////////////////////////

        var previousColorScheme = colorScheme;
        buttonSwitchColor(ebID('buttColor' + colorScheme), true);

        for (var i = 1; i < maxColor + 1; i++) {
          (function (i) {
            ebID('buttColor' + i).addEventListener('click', function () {
              previousColorScheme = colorScheme;
              colorScheme = i;
              document.body.dispatchEvent(colorChanged);
            });
          }(i));
        }

        var colorChanged = new Event('colorChanged'); // triggered by plus/minus buttons

        document.body.addEventListener('colorChanged', function (e) {
          buttonSwitchColor(ebID('buttColor' + previousColorScheme), false);
          buttonSwitchColor(ebID('buttColor' + colorScheme), true);
          if (!play) updateBandMesh(k, hl);
          refresh = true;
        }, false);


        var tubeMid = [];
        ebID('buttShowMid').addEventListener('click', function () {
          showMid = !showMid;
          buttonSwitchColor(ebID('buttShowMid'), showMid);
          if (showMid) createTube(tubeMid, 1, 0.5 * 3, yellow);
          else {
            meshDispose(tubeMid);
            meshDispose(golf);
          }
          refresh = true;
        });
        ///////////////////////////////////////////////////////////////////////////////////

        camera.attachControl(canvas, false);

        function refreshScene() { refresh = true; } // to prevent freezing of the render window after long inactivity
        setInterval(refreshScene, 1000);





        //#############################################################
        //#############################################################
        scene.registerBeforeRender(function () {
          if (play || k == 0) {
            updateBandMesh(k, hl);
            // move clock hand
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(k));
            dot.setAttribute('cy', -40 * Math.cos(k));
            if (play) k += speedy;
          }
        });
        //#############################################################
        //#############################################################


        // the canvas/window resize event handler
        window.addEventListener('resize', function () { engine.resize(); refresh = true; });

        function rend() {
          scene.render();
        }

        var customRender = function () {
          if (refresh || play ||
            Math.abs(camera.inertialRadiusOffset) > 0 ||
            Math.abs(camera.inertialAlphaOffset) > 0 ||
            Math.abs(camera.inertialBetaOffset) > 0) {
            scene.render();
          }
          if (refresh) refresh = false;
        }
        engine.stopRenderLoop(); // Stop the automatic PG rendering
        rend(); // Render the first frame.
        engine.runRenderLoop(customRender); //start main render loop

        //document.body.addEventListener('nuiChanged', function () { console.log("updated value of nu index is " +  parseInt(nuSlider.getValue()))});





        var showEnergy = false;
        var showKappa = false;
        var showEversionPath = false;




        ebID('buttShowEnergy').addEventListener('click', function () {
          showEnergy = !showEnergy;
          buttonSwitchColor(ebID('buttShowEnergy'), showEnergy);

          if (showEnergy == false) {
            contentK.style.top = '0%';
            contentE.style.height = '0%';
            destroyChart(chart);  // Destroy the chart when showEnergy is false
          } else {
            contentE.style.height = '25%';
            //nu_i = parseInt(nuSlider.getValue());
            createChart(nu_i);
            document.body.addEventListener('nuiChanged', function () {
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);

              if (showKappa == true) {
                contentK.style.top = '25%';
              }

            });
            document.body.dispatchEvent(energyChanged);

            document.body.addEventListener('nChanged', function (e) {
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);
            });
            document.body.addEventListener('plotClicked', function (e) {
              nu_i = e.detail.nu_i;
              n = e.detail.n;
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);
            });

            // Create the chart when showEnergy is true
          }
        });
        // energy changed during the tour
 

        ////////////////////////////////////////////////////////////////
        // create the chart for curvature 
        ////////////////////////////////////////////////////////////////






        // creating the plot for paths
        //var curve = paths(n, hingeLength, type, ind);




        ebID('buttShowKappa').addEventListener('click', function () {
          showKappa = !showKappa;
          buttonSwitchColor(ebID('buttShowKappa'), showKappa);

          if (showKappa == false) {
            contentK.style.height = '0%';
            destroyChart(chartK);  // Destroy the chartK when showKappa is false
          } if (showKappa == true) {
            if (showEnergy == true) {
              contentK.style.top = '25%';
            }
            contentK.style.height = '22%';
            //  createchartK(kappa);

            document.body.addEventListener('energyChanged', function () {
              contentK.style.top = '25%';
            });


            if (showEnergy === false) {
              contentK.style.top = '0%';
            }





            // Create the chartK when showKappa is true
          }
        });





        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////


        return scene;
      }

      var scene = createScene(); // call the createScene function

      // Create a custom event
      var openColorPickerEvent = new Event('openColorPicker');


      ebID('backgroundButton').addEventListener('openColorPicker', function () {
        // Trigger the color picker
        ebID('colorPicker').click();
      });

      // Keep the existing 'click' event listener as well
      ebID('backgroundButton').addEventListener('click', function () {
        ebID('colorPicker').click();
      });


      ebID('colorPicker').addEventListener('input', function () {
        // Get the color value from the color picker
        var colorVal = this.value;

        // Convert hex color to RGB
        var r = parseInt(colorVal.substr(1, 2), 16) / 255;
        var g = parseInt(colorVal.substr(3, 2), 16) / 255;
        var b = parseInt(colorVal.substr(5, 2), 16) / 255;

        // Update the scene's background color
        scene.clearColor = new BABYLON.Color3(r, g, b);
      });


    });



   /// functions for the tour 
   


   function moveCursorToPosition(x, y, callback) {
      const cursor = document.querySelector('.cursor');
      cursor.style.left = x -13+ 'px';
      cursor.style.top = y -5+ 'px';

      setTimeout(() => {
        if (typeof callback === "function") {
          callback();
        }
      }, 1000); // Adjust the delay as needed
    }
 

    // Function to simulate a click
    function simulateClick(elementId) {
      const element = ebID(elementId);
      if (element) {
        var clickEvent = new MouseEvent("click", {
          "view": window,
          "bubbles": true,
          "cancelable": false
        });
        element.dispatchEvent(clickEvent);

      }

    }

    function moveCursorToElement(elementId, callback) {
      const cursor = document.querySelector('.cursor');
      const element = ebID(elementId);

      if (element) {
        const elementRect = element.getBoundingClientRect();
        const cursorX = elementRect.left + elementRect.width / 2;
        const cursorY = elementRect.top + elementRect.height / 2;

        cursor.style.left = cursorX + 'px';
        cursor.style.top = cursorY + 'px';

        setTimeout(() => {
          callback();
        }, 1000); // Adjust the timeout to match the duration of the CSS transition
      }
    }

    const svg = document.querySelector('svg'); // Adjust selector as needed
    const svgRect = svg.getBoundingClientRect();

    function getCircleCenterPosition(circleId) {
      const circle = ebID(circleId);
      const cx = parseInt(circle.getAttribute('cx'));
      const cy = parseInt(circle.getAttribute('cy'));

      // Adjust by the SVG container's position
      const x = svgRect.left + cx + window.scrollX;
      const y = svgRect.top + cy + window.scrollY;

      return { x, y };
    }
 


    // Function to simulate a click at specific pixel coordinates
    function simulateClickAt(x, y, elementId) {
      const element = document.getElementById(elementId);
      if (element) {
        var clickEvent = new MouseEvent('click', {
          clientX: x,
          clientY: y,
          bubbles: true,
          cancelable: true
        });
        element.dispatchEvent(clickEvent);
      }
    }

    // Function to get pixel coordinates for a given index
    function getPixelCoordinatesForIndex(index) {
      // Assuming xData and yData are globally accessible
      const xValue = xData[index];
      const yValue = yData[index];

      // Convert these values to pixel coordinates on the canvas
      // This depends on how your chart scales and canvas are set up
      // Example calculation (you may need to adjust this):
      // Use Chart.js's internal methods to convert data values to pixel values
      const xPixel = chart.scales.x.getPixelForValue(xValue);
      const yPixel = chart.scales.y.getPixelForValue(yValue);

      return { x: xPixel, y: yPixel };
    }


    /// adding step for speed slider 

    var tourSliderMin;
    var tourSliderMax;

    function calculateSliderClickPosition(sliderId, value) {
      const slider = ebID(sliderId);
      const sliderRange = [tourSliderMin, tourSliderMax]; // Min and max values of the slider
      const sliderWidth = 200; // Width of the slider in pixels

      // Calculate the proportional position of the value
      const valueRatio = (value - sliderRange[0]) / (sliderRange[1] - sliderRange[0]);
      // Adjusting positionX to start from the left edge of the slider
      const positionX = (valueRatio * sliderWidth); // Subtract 100 because the viewbox starts at -100

      return positionX;
    }



    function simulateClickOnSlider(sliderId, value, callback) {
      const positionX = calculateSliderClickPosition(sliderId, value);
      const slider = ebID(sliderId);

      if (slider) {
        const sliderRect = slider.getBoundingClientRect();
        const cursor = document.querySelector('.cursor');

        // Calculate the exact position for the cursor
        const clickPositionX = sliderRect.left + positionX + window.scrollX;
        const clickPositionY = sliderRect.top + sliderRect.height / 2 + window.scrollY;

        // Move the cursor to the calculated position
        cursor.style.left = clickPositionX + 'px';
        cursor.style.top = clickPositionY + 'px';

        // Simulate the click after a short delay to allow for cursor movement
        setTimeout(() => {
          var clickEvent = new MouseEvent("click", {
            clientX: clickPositionX,
            clientY: clickPositionY,
            bubbles: true,
            cancelable: true
          });
          slider.dispatchEvent(clickEvent);

          // Execute the callback function after the click
          if (typeof callback === "function") {
            setTimeout(callback, 1000); // Adjust timeout as needed
          }
        }, 1000); // Adjust the timeout for cursor movement
      }
    }



    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////

    ///     starting the tour 
    const tour = new Shepherd.Tour(
      {
    
      
      defaultStepOptions: {
        cancelIcon: {
          enabled: true
        },
        classes: 'shepherd-theme-arrows',
        scrollTo: true
      }
    });

 
    

    tour.addStep({
      title: 'Increase Twists',
      text: `This button increases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetPlus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetPlus', () => {
           
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
          simulateClick('buttNumOfTetPlus');
        }
      }
    });

    // Similar setup for 'buttNumOfTetMinus'

    tour.addStep({
      title: 'decrease Twists',
      text: `This button decreases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetMinus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetMinus', () => {
           
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
          simulateClick('buttNumOfTetMinus');
        }
      }
    });


    // Play eversion

    tour.addStep({
      title: 'play',
      text: `This button plays the everting motion. Drag the clock right to modify the everting states.`,
      attachTo: {
        element: '#playPausePoly',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('playPausePoly', () => {
            
            setTimeout(() => tour.next(), 2500); // Proceed to next step after the action
          });
          simulateClick('playPausePoly');
        }
      }
    });



    var tourSpeed;
    tourSliderMin = 4;
    tourSliderMax = 100;
    tour.addStep({
      title: 'Adjust Speed',
      text: 'Click on this slider to change the speed of eversion.',
      attachTo: {
        element: '#speedSlider',
        on: 'bottom'
      },
      when: {
        show: function () {
          simulateClickOnSlider('speedSlider', 20, () => {
            tour.next();
          });
 
        }
      }
    });
    tour.addStep({
      title: 'Adjust Speed',
      text: 'Click on this slider to change the speed of eversion.',
      attachTo: {
        element: '#speedSlider',
        on: 'bottom'
      },
      when: {
        show: function () {
          simulateClickOnSlider('speedSlider', 40, () => {
            tour.next();
          });

          tourSpeed = new Event('tourSpeed');
   
          ebID('speedSlider').dispatchEvent(tourSpeed);
        }
      }
    });
 
    // width 
    var tourWidth;
    var tourWidthBack;
    tourSliderMin = 0;
    tourSliderMax = 100;

    tour.addStep({
      title: 'Adjust band width',
      text: 'Click on this slider to change the width of the band.',
      attachTo: {
        element: '#hingeLengthSlider',
        on: 'bottom'
      },
      when: {
        show: function () {
          simulateClickOnSlider('hingeLengthSlider', 40, () => {
            tour.next();
          });
          tourWidth = new Event('tourWidth');
    
          ebID('hingeLengthSlider').dispatchEvent(tourWidth);
        }
      }
    });
    tour.addStep({
      title: 'Adjust band width',
      text: 'Click on this slider to change the width of the band.',
      attachTo: {
        element: '#hingeLengthSlider',
        on: 'bottom'
      },
      when: {
        show: function () {
          simulateClickOnSlider('hingeLengthSlider', 20, () => {
            tour.next();
          });
           tourWidthBack = new Event('tourWidthBack');
          ebID('hingeLengthSlider').dispatchEvent(tourWidthBack);
        }
      }
    });


    // view angle 

    tour.addStep({
      title: 'view axis',
      text: `view along the axis of symmetry.`,
      attachTo: {
        element: '#buttAlignAxis',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttAlignAxis', () => {
            simulateClick('buttAlignAxis');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
         }
      }
    });
    tour.addStep({
      title: 'view axis',
      text: `view along the plane of symmetry.`,
      attachTo: {
        element: '#buttAlignPlane',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttAlignPlane', () => {
            simulateClick('buttAlignPlane');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
         }
      }
    });

    // change the camera angle to default
    alpha = 6.185710546084945;
    beta = 1.0989063024750556;
    var tourCamera;
    tour.addStep({
      title: 'view angle',
      text: `hold the left click and move the mouse to rotate the band.`,
      attachTo: {
        element: '#renderCanvas',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('renderCanvas', () => {

            setTimeout(() => tour.next(), 3000); // Proceed to next step after the action
          });
          tourCamera= new CustomEvent('tourCamera', { detail: { alpha: alpha, beta: beta } });
          ebID('renderCanvas').dispatchEvent(tourCamera);
        }
      }
    });

    // eversion path 
    tour.addStep({
      title: 'view eversion path',
      text: `path of eversion of a point on the midline.`,
      attachTo: {
        element: '#buttShowMid',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowMid', () => {
            simulateClick('buttShowMid');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });
    tour.addStep({
      title: 'view unit',
      text: `1/n th of the band with n half twists.`,
      attachTo: {
        element: '#buttShowUnit',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowUnit', () => {
            simulateClick('buttShowUnit');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });
    tour.addStep({
      title: 'view unit',
      text: `1/n th of the band with n half twists.`,
      attachTo: {
        element: '#buttShowUnit',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowUnit', () => {
            simulateClick('buttShowUnit');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });


    tour.addStep({
      title: 'view energy plot',
      text: `plot of the bending energy of stable bands versus the torsion of the midline of the band.`,
      attachTo: {
        element: '#buttShowEnergy',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowEnergy', () => {
            simulateClick('buttShowEnergy');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });
 

    tour.addStep({
      title: 'view curvature',
      text: `curvature of the midline during eversion.`,
      attachTo: {
        element: '#buttShowKappa',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowKappa', () => {
            simulateClick('buttShowKappa');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });


    // eversion path 
    tour.addStep({
  //    title: 'view eversion path',
    //  text: `path of eversion of a point on the midline.`,
      attachTo: {
        element: '#buttShowMid',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowMid', () => {
            simulateClick('buttShowMid');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

 
    tour.addStep({
      title: 'modify band',
      text: 'clicking on the plot shows a band corresponding to the dimensionless torsion of the midline on the x axis.',
      attachTo: {
        element: '#renderCanvasE',
        on: 'bottom'
      },
      when: {
        show: function () {
          const index = 40; // Example index
          nu_i = index;
          const coordinates = getPixelCoordinatesForIndex(index);

          // Adjust the coordinates to account for canvas position
          var canvasRect = document.getElementById('renderCanvasE').getBoundingClientRect();
          const adjustedX = canvasRect.left + coordinates.x;
          const adjustedY = canvasRect.top + coordinates.y;

          moveCursorToPosition(adjustedX, adjustedY, () => {
            nui_to_n(index);
            simulateClickAt( adjustedX, adjustedY,'renderCanvasE'); 
                setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });

        }
      }
    });
   

 
    // going back to the optimal bands 

    tour.addStep({
      text: 'clicking here will show the optimal bands',
      //text: `This button decreases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetMinus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetMinus', () => {
            simulateClick('buttNumOfTetMinus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    tour.addStep({
      text: 'clicking here will give the optimal bands',
      // text: `This button decreases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetMinus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetMinus', () => {
            simulateClick('buttNumOfTetMinus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

 

    // colors 
    tour.addStep({
      title: 'view colors',
      text: `change color of the band.`,
      attachTo: {
        element: '#buttColor2',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttColor2', () => {
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
          simulateClick('buttColor2');
        }
      }
    });
    // colors 
    tour.addStep({
      title: 'view colors',
      text: `change color of the band.`,
      attachTo: {
        element: '#buttColor1',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttColor1', () => {
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
          simulateClick('buttColor1');
        }
      }
    });


 
    // Shepherd tour step
    tour.addStep({
      title: 'View Colors',
      text: 'Change the background color using the picker on the top-left.',
      attachTo: {
        element: '#backgroundButton',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('backgroundButton', () => {
            simulateClick('backgroundButton');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });



    tour.on('complete', function () {
      const cursor = document.querySelector('.cursor');
      if (cursor) {
        cursor.style.display = 'none'; // Hide the cursor
      }
    });

    // for continuing hovering

    const leftBar = document.querySelector('.leftbar');
    const rightBar = document.querySelector('.rightbar');

    tour.on('start', function () {
      leftBar.classList.add('simulated-hover');
      rightBar.classList.add('simulated-hover');
    });

    tour.on('complete', function () {
      leftBar.classList.remove('simulated-hover');
      rightBar.classList.remove('simulated-hover');
    });

    tour.on('cancel', function () {
      leftBar.classList.remove('simulated-hover');
      rightBar.classList.remove('simulated-hover');
    });


    // Start the tour

    // ...add more steps for other buttons...

    // Start the tour
    var showTour = true;
    window.startTour = function () {
      
      const cursor = document.querySelector('.cursor');
      if (cursor) {
        cursor.style.display = 'block'; // Show the cursor
      }
      tour.start();

      if (showTour == false) {
        tour.cancel();
      }


    }



    document.addEventListener('DOMContentLoaded', function () {
      // Show the modal
      ebID('tourModal').style.display = 'block';
    });

    // Start tour when "Start Tour" button is clicked
    ebID('startTourBtn').addEventListener('click', function () {



      window.startTour();
      ebID('tourModal').style.display = 'none'; // Hide modal
    });

    // Close modal when "No Thanks" button is clicked
    ebID('dismissTourBtn').addEventListener('click', function () {
      ebID('tourModal').style.display = 'none'; // Hide modal
    });

    // document.addEventListener('keydown', function(event) {
    //   if (event.key === 'c' || event.key === 'C') {
    //     // Stop the tour
    //     if (tour.isActive()) {
    //       tour.cancel(); // or tour.complete();
    //     }

    //     // Hide the cursor
    //     const cursor = document.querySelector('.cursor');
    //     if (cursor) {
    //       cursor.style.display = 'none';
    //     }
    //   }
    // });




  </script>

</body>

</html>
