<!DOCTYPE html>
<html>

<head>
  <meta http-equiv='Content-Type' content='text/html' charset='utf-8' />
  <title>M&ouml;bius bands</title>
  <link href='utils/3M_favicon.png' rel='icon'>
  <link rel='stylesheet' type='text/css' href='utils/kN.css'>
  <link rel="stylesheet" href='utils/shepherd.css'>
  <script src='utils/babylon.custom.js'></script>
  <script src='utils/jscolor.js'></script>

  <script src='utils/util.js'></script>
  <script src='utils/tetToggler.js'></script>
  <script src='utils/kN3.js'></script>
  <script src='utils/data_lower_envelope.js'></script>

  <script src='utils/chart.umd.js' defer></script>
  <script src='utils/plotly.js' defer></script>
  <script src='utils/mathjax_min.js' defer></script>



  <!-- Shepherd.js JavaScript -->
  <script src='utils/shepherd.js'></script>
  <!-- <script src='utils/tour.js'></script> -->

</head>

<body>



  <div class='leftbar'>

    <svg width='200' height='110' viewBox='-100 -55 200 110' style='margin-top:10px'>
      <g class='touchElement' id='buttNumOfTetMinus'>
        <title>decrease the number n of half twists of the optimal band with n fold rotational symmetry</title>
        <circle cx='-62' cy='10' r='34' /> <!-- Modified cy here -->
        <polygon points='-80 7 -80 13 -44 13 -44 7' fill='#fff' /> <!-- Adjusted y values in points -->
      </g>
      <g class='touchElement' id='buttNumOfTetPlus'>
        <title>increase the number n of half twists of the optimal band with n fold rotational symmetry</title>
        <circle cx='62' cy='10' r='34' /> <!-- Modified cy here -->
        <polygon points='80 7 80 13 65 13 65 28 59 28 59 13 44 13 44 7 59 7 59 -8 65 -8 65 7' fill='#fff' />
        <!-- Adjusted y values in points -->
      </g>
      <g class="textElement" id='infoTet'>
        <text y='-40'>number of half twists</text>
        <text id='infoNumOfTet' y='16'>3</text>
      </g>
    </svg>

    <!-- <svg id='nuSlider' class='slider' width='200' height='100' viewBox='-100 -25 200 50'>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg> -->
    <!-- <svg id='nuSlider' class='slider' width='200' height='100' viewBox='-100 -25 200 50'>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg> -->
    <svg id='tetTogStar' class='tetTogStar' width='0 ' height='0' viewBox='-600 -600 1200 1200'></svg>

    <svg id='playSVG' width='200' height='200' viewBox='-60 -60 120 120' style='margin-top:10px'>
      <g class='touchElement' id='buttPlayPause'>
        <title> click to play the everting motion</title>
        <circle cx='0' cy='0' r='20' />
        <polygon id='playPausePoly' points='-7 -10 -7 10 13 0' fill='#fff' />
      </g>
      <g class='touchElement' id='clockRing'>
        <title> drag to evert the band</title>
        <circle cx='0' cy='0' r='40' fill='none' stroke='#555' stroke-width='26' />
        <circle id='clockHand' r='12' fill='#fff' />
      </g>
    </svg>


    <svg id='speedSlider' class='slider' width='200' height='100' viewBox='-100 -25 200 50'>
      <title> slide to change the speed of eversion</title>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg>

    <svg id='hingeLengthSlider' class='slider' width='200' height='100' viewBox='-100 -25 200 50'>
      <title> slide to change the width of the band</title>
      <polygon fill='#555' points='-100 -20 -100 20 100 20 100 -20' />
      <rect width='38' height='38' x='-19' y='-19' />
      <text x='-100' y='-25'></text>
    </svg>
    <br>
    <br>
    <g class="textElement">
      <text> view angle </text>
    </g>
    <button class='button' id='buttAlignAxis' title='align the view with the axis of symmetry'> align axis </button>
    <button class='button' id='buttAlignPlane' title='align the view with the best fit plane'> align plane </button>
  </div>

  <div class='rightbar'>
    <button class='button' id='buttFullScreen' title='enable full screen'> full screen </button>
    <br>
    <br>
    <button class='button' id='buttShowMid' title='path traced by a point on the midline
    of the band  during the everting motion'> eversion path </button>
    <button class='button' id='buttShowUnit' title='show 1/n th of the band with n half twists '> show unit </button>
    <!-- <button class='button' id='buttShowAxis'> show axis </button> -->
    <br>
    <br>
    <!-- <g class="textElement">

      <text> physics </text>
    </g> -->

    <button class='button' id="buttShowEnergy"
      title='dimensionless torsion of the midline versus dimensionless bending energy of the stable bands. click on the plot to change the torsion'>
      bending energy</button>
    <button class='button' id="buttShowKappa"
      title='curvature of the midline. the rainbow color corresponds to the arclength. the n red dots are evenly spaced points on the band with n half twists'>
      curvature</button>

    <br>
    <br>
    <g class="textElement">

      <text> colors </text>
    </g>
    <button class='button' id='buttColor1' title='ranbow color scheme for the surface of the band'> rainbow </button>
    <button class='button' id='buttColor2' title='two faces of the band colored with white and red'> digital </button>
    <!-- <button class='button' id='buttColor3'> M&ouml;bius rainbow 3 </button>
    <button class='button' id='buttColor4'> digital </button>
    <button class='button' id='buttColor5'> M&ouml;bius BRW 3 </button> -->


    <button class='button' id="backgroundButton"
      title='change the background color for the best visibility using picker on the left-top'>background Color</button>
    <input type="color" id="colorPicker" style="display: none;">

    <!-- <input class="jscolor" value="ab2567" data-jscolor="{format:'rgba', position:'right', width:181, height:101}"> -->


  </div>

  <div class="container">
    <div class="content">
      <canvas id='renderCanvas' touch-action='none'></canvas>
      <img src='utils/dragon_oist.svg' style='height:40px;position:absolute;left:0;bottom:0;margin:10px'>
      <img src='utils/3M_white.svg' style='height:40px;position:absolute;right:0;bottom:0;margin:10px'>
    </div>
  </div>
  <div class="contentE">
    <canvas id='renderCanvasE' touch-action='none'></canvas>
  </div>
  <div class="contentK">
    <canvas id='renderCanvasK' touch-action='none'></canvas>
  </div>

  </div>

  <div id="animatedCursor"></div>


  <div id="tourModal" class="modal-backdrop">
    <div class="modal-content">
      <h2>Welcome!</h2>
      <p>Would you like a guided tour of the application?</p>
      <button id="startTourBtn" class="modal-button">Start Tour</button>
      <button id="dismissTourBtn" class="modal-button">No Thanks</button>
    <!-- <p> Press c on the keyboard to interrupt the tour.</p> -->
    </div>
  </div>

  

  <script>

    var energy;
    var colEnergy;
    var ind_energy;
    var xData;
    var yData;
    colEnergy = colEnergy.map(rgb => rgb.map(val => Math.round(val * 255)));


    var contentE = document.querySelector('.contentE');
        var content = document.querySelector('.content');
        var contentK = document.querySelector('.contentK');
        var contentPath = document.querySelector('.contentPath');

   var chart  ;  // Declare chart variable
    var chartK ;  // Declare chart variable
   var createChart;
    var linspace = function (start, end, num) {
      var step = (end - start) / (num - 1);
      var result = [];

      for (var i = 0; i < num; i++) {
        var value = start + step * i;
        result.push(value);
      }

      return result;
    }

    'use strict';

    if (document.documentMode || /Edge/.test(navigator.userAgent)) {
      alert('MICROSOFT ALARM: You are using strange software which may lead to unexpected behavior of the website. Please use a reasonable 21st century browser, like, for example: Chrome, Firefox, Opera, Safari,...');
    }




    document.addEventListener('DOMContentLoaded', function () {
      const elements = document.querySelectorAll('.leftbar .touchElement, .leftbar .slider, .rightbar .touchElement, .rightbar .slider, .leftbar .button, .rightbar .button, .leftbar .textElement, .rightbar .textElement');
      elements.forEach(el => el.classList.add('default-visible'));

      setTimeout(() => {
        elements.forEach(el => el.classList.remove('default-visible'));
      }, 5000);
    });



    window.addEventListener('DOMContentLoaded', function () {
      // get the canvas DOM element
      var canvas = ebID('renderCanvas');

      // load the 3D engine
      var engine = new BABYLON.Engine(canvas, true);

      // createScene function that creates and return the scene
      var createScene = function () {
        // create a basic BJS Scene object
        var scene = new BABYLON.Scene(engine);
        scene.useRightHandedSystem = true;
        scene.clearColor = new BABYLON.Color3(0.3254901960784314, 0.396078431372549, 0.3686274509803922);
        // camera Math.PI
        var camera = new BABYLON.ArcRotateCamera('ArcRotateCamera', Math.PI, 0, 1.2, new BABYLON.Vector3.Zero(), scene);
        camera.lowerRadiusLimit = .1;
        camera.upperRadiusLimit = 100;
        camera.wheelPrecision = 100;
        camera.pinchPrecision = 200;
        scene.activeCamera.panningSensibility = 0;
        camera.alpha = 6.185710546084945;
        camera.beta = 1.0989063024750556;
        camera.radius = 3;
        ///////////////////////////////////////////////////////////////////////////////////

        var light = new BABYLON.SpotLight('spotLight', new BABYLON.Vector3(-.0, 1.5, 0), new BABYLON.Vector3(1, 1, 1), Math.PI / 2, .1, scene);
        light.shadowIntensity = 1.0;
        light.shadowBlur = 4;

        // Set the target of the light to be the camera position
        light.setDirectionToTarget(camera.position);
        // light.parent = camera;

        var white = new BABYLON.StandardMaterial('texture1', scene);
        var cyan = new BABYLON.StandardMaterial('texture1', scene);
        var yellow = new BABYLON.StandardMaterial('texture1', scene);
        var red = new BABYLON.StandardMaterial('texture1', scene);
        var trans = new BABYLON.StandardMaterial('texture1', scene);
        white.diffuseColor = new BABYLON.Color3(1, 1, 1);
        cyan.diffuseColor = new BABYLON.Color3(0, 1, 1);
        yellow.diffuseColor = new BABYLON.Color3(1, 1, 0);
        red.diffuseColor = new BABYLON.Color3(1, 0, 0);
        //cyan.wireframe = true;
        trans.alpha = 0.7;

        var bandMat = new BABYLON.StandardMaterial('texture1', scene);

        bandMat.diffuseColor = new BABYLON.Color3(1, 1, 0);


        // var ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 4, height: 4 }, scene);
        // var groundMaterial = new BABYLON.StandardMaterial('groundMaterial', scene);
        // groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2); // Set a dark color for the ground

        // groundMaterial.specularColor = new BABYLON.Color3(1, 1, 1);; // Disable specular highlights

        // ground.position = new BABYLON.Vector3(0, -.7, 0);

        // ground.material = groundMaterial;


        // Create a new standard material 'glass' 
        var glass = new BABYLON.StandardMaterial("glass", scene);

        // Make it transparent
        glass.alpha = 0.045;
        // Give it a high specular power for glossiness
        glass.specularPower = 100;
        // Give it a low diffusivity so it doesn't scatter light
        glass.diffuseColor = new BABYLON.Color3(1, 1, 1, .1);
        // Set its index of refraction to something like glass
        glass.indexOfRefraction = 1.52;

        //scene.clearColor = new BABYLON.Color3(0, 0, 0);
        //scene.createDefaultSkybox(backgroundTexture, true);



        ///////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////


        var n = 3;
        var nMax = 75;
        var hl = 0.2;
        var speedy = 0.01;
        var k = 0;
        var play = false;
        var refresh = false;
        var colorScheme = 1;
        var maxColor = 2;
        // var N = 240

        // Set the material of the arrow



        var golf = [];

        var numData;
        var parameters = [[3, 1, 1, 24],
        [5, 25, 70, 93],
        [7, 94, 135, 160],
        [9, 161, 199, 224],
        [11, 225, 262, 288],
        [13, 289, 325, 351],
        [15, 352, 388, 414],
        [17, 415, 449, 476],
        [19, 477, 511, 539],
        [21, 540, 573, 600],
        [23, 601, 634, 662],
        [25, 663, 695, 722],
        [27, 723, 756, 770]];;  // parameters n N and tau 


        var hx0;
        var hy0;
        var hz0;

        var tx0;
        var ty0;
        var tz0;

        var rx0;
        var ry0;
        var rz0;



        var rx;
        var ry;
        var rz;

        var nu_i = 1;

        init_parameters(nu_i);
        data_t0(nu_i);



        var midlineMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        midlineMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        midlineMaterial.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);

        var optionsMidline = [];
        var midline = [];

        // rulings 
        var rulingsMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        rulingsMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        rulingsMaterial.emissiveColor = new BABYLON.Color4(1, 1, 1, 1);

        var optionsRulings = [];
        var rulings = [];



        function midlineInit() {
          // Update the path
          var initialPath = [];
          for (var i = 0; i < N + 1; i++) {
            initialPath.push(new BABYLON.Vector3(0, 0, 0));
          }

          optionsMidline = {
            path: initialPath, //vec3 array,
            radius: 0.004, // set the radius of the tube
            updatable: true
          };
          // Update the tube mesh with the new data
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline, scene);
          midline.material = midlineMaterial;

          // initialize rulings 


          for (var i = 1; i < n + 1; i++) {
            let temp = [];
            temp.push(new BABYLON.Vector3(0, 0, 0));
            temp.push(new BABYLON.Vector3(0, 0, 0));

            optionsRulings = {
              path: temp, //vec3 array,
              radius: 0.01, // set the radius of the tube
              updatable: true
            };

            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings, scene);
            rulings[i].material = rulingsMaterial;


          };

        };
        midlineInit();




        function k_to_t(k) {
          return Math.round(k * N / (2 * Math.PI));
        };
        var t;


        var kappa;
        var eversionPlay = new Event('eversionPlay'); // triggered by plus/minus buttons

        var vertexData = [];
        var vertexDataBack = [];
        var band = new BABYLON.Mesh('custom', scene);
        var bandBack = new BABYLON.Mesh('custom', scene);



        function updateTetrahedra(k, hingeLength) {
          t = k_to_t(k);
          let temp = fourierExpansion(N, t, hingeLength);
          var v = temp[0];

          // updating curvature 
          kappa = temp[1].concat();
          document.body.dispatchEvent(eversionPlay);


          if (showKappa == true) {
            if (chartK != null) {
              destroyChart(chartK);
            }
            createchartK(kappa);
          }

          if (showEversionPath == true) {
            if (plotCreated == true) {
              clearPlot();
            }

            createPlot();
          }






          // N = 105;
          var pos = [];
          var pathMidline = [];
          var indices = [];
          var indicesBack = [];
          var colors = [];
          var colorsBack = [];

          for (var i = 1; i < N + 1; i++) {
            var v1 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
            var v2 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];



            pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

            // surface 

            pos.push(v1[0], v1[1], v1[2]);
            pos.push(v2[0], v2[1], v2[2]);

            if (colorScheme == 1) {
              var c1 = jet(i - 1);

              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            } else {
              colors.push(1, 1, 1, 1);
              colors.push(1, 1, 1, 1);
              colorsBack.push(1, 0, 0, 1);
              colorsBack.push(1, 0, 0, 1);
            }

            if (i > 0) {
              indices.push(2 * i - 1, 2 * i, 2 * i - 2);
              indices.push(2 * i, 2 * i - 1, 2 * i + 1);

              indicesBack.push(2 * i, 2 * i - 1, 2 * i - 2);
              indicesBack.push(2 * i - 1, 2 * i, 2 * i + 1);

            };
          };

          //   console.log(pathMidline)
          // Update the tube mesh with the new path
          // Remove the existing tube mesh


          i = 1;
          var v2 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
          var v1 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];

          pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

          pos.push(v1[0], v1[1], v1[2]);
          pos.push(v2[0], v2[1], v2[2]);

          if (colorScheme == 1) {
            var c1 = jet(i - 1);

            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
          } else {
            colors.push(1, 1, 1, 1);
            colors.push(1, 1, 1, 1);
            colorsBack.push(1, 0, 0, 1);
            colorsBack.push(1, 0, 0, 1);
          }

          // indicesBack.push(2*N-1, 1, 0);
          // indicesBack.push(2*N-1, 0, 2*N);

          //   indices.push( 0,2*N-1, 2*N);
          //   indices.push( 1,2*N-1, 0);


          var normals = [];
          BABYLON.VertexData.ComputeNormals(pos, indices, normals);

          var vertexData = new BABYLON.VertexData();
          vertexData.positions = pos;
          vertexData.indices = indices;
          vertexData.normals = normals;
          vertexData.colors = colors;

          vertexData.applyToMesh(band);



          var normalsBack = [];
          BABYLON.VertexData.ComputeNormals(pos, indicesBack, normalsBack);
          vertexDataBack = new BABYLON.VertexData();
          vertexDataBack.positions = pos;
          vertexDataBack.indices = indicesBack;
          vertexDataBack.normals = normalsBack;
          vertexDataBack.colors = colorsBack;

          vertexDataBack.applyToMesh(bandBack);

          ///  surface created 

          /// creating midline 

          // Update
          optionsMidline.path = pathMidline;
          optionsMidline.instance = midline;
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline); //No scene parameter when using instance
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);


          if (showUnit) {
            // Enable vertex alpha for the mesh
            band.hasVertexAlpha = true;
            bandBack.hasVertexAlpha = true;

            // Disable backface culling
            //band.backFaceCulling = false;
            //bandBack.backFaceCulling = false;

            var vertexData = band.getVerticesData(BABYLON.VertexBuffer.ColorKind);
            var vertexDataBack = bandBack.getVerticesData(BABYLON.VertexBuffer.ColorKind);

            // Ensure the vertex buffer is large enough to accommodate the modifications
            if (!vertexData || vertexData.length < 4 * (N + 1)) {
              vertexData = new Float32Array(4 * (N + 1));
            }
            if (!vertexDataBack || vertexDataBack.length < 4 * (N + 1)) {
              vertexDataBack = new Float32Array(4 * (N + 1));
            }

            var ind = Math.round(N / n) + 1;
            for (var i = ind; i < N + 1; i++) {
              var j = 2 * i;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 1;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 2;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 3;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;
            }

            // Update the vertex colors with modified alpha values
            band.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexData);
            bandBack.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexDataBack);


          };




          var ind1 = Math.round(N / (2 * n));

          for (var j = 1; j < golf.length + 1; j++) {
            let l = 2 * j * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            if (golf[j]) {
              golf[j].position = new BABYLON.Vector3((v1[0] + v2[0]) / 2,
                (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2);

            };

          };



          var ind1 = Math.round(N / (2 * n));


          // creating rulings 
          for (var i = 1; i < n + 1; i++) {
            // l =  i * ind1   ;
            l = 2 * i * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            let path = [];
            path.push(new BABYLON.Vector3(v1[0], v1[1], v1[2]));
            path.push(new BABYLON.Vector3(v2[0], v2[1], v2[2]));

            optionsRulings.path = path;
            optionsRulings.instance = rulings[i];
            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings); //No scene parameter when using instance


          };

          // meshDispose(golf) 

        };




        // tube paths /////////////////////////////////////////////////////////////////////

        function createTube(tube, type, hingeLength, color) {
          var ind0 = Math.round(N / (2 * n));
          for (var i = 1; i < n + 1; i++) {
            var ind = 2 * i * ind0 - 2 * ind0 + 1;

            var curve = paths(n, hingeLength, type, ind);
            tube[i] = BABYLON.Mesh.CreateTube('tube', curve, 0.0025, 8, null, null, scene);
            tube[i].material = color;
            golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
              'ico', { radius: 0.03, subdivisions: 8, flat: false, updatable: false }, scene);
            golf[i].material = red;
            updateTetrahedra(k, hl);

          }
          // if (type == 2) { // midpoints get golf
          //   for (var i = 1; i < n + 1; ++i) {
          //     golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
          //       'ico', { radius: 0.03, subdivisions: 8, flat: false, updatable: false }, scene);
          //     golf[i].material = color;
          //   }
          // updateTetrahedra(k, hl);
          // }
        }


        // plane //////////////////////////////////////////////////////////////////////////

        function enablePlane(bool) {


        }


        // dispose mesh ///////////////////////////////////////////////////////////////////

        function meshDispose(me) {
          var i = 1;
          while (me[i]) {
            me[i].dispose();
            i += 1;
          }
        }

        var nu_min = 1;
        var nu_max = 24;
        var nu_opt = 1;



        var n_to_nui = function (n) {
          let ind = parseInt(Math.round((n - 1) / 2) - 1);
          nu_min = parseInt(parameters[ind][1]);
          nu_opt = parseInt(parameters[ind][2]);
          nu_max = parseInt(parameters[ind][3]);
        };

        var nui_to_n = function (nu_i) {
          n = null;

          for (let i = 0; i < parameters.length; i++) {
            const row = parameters[i];
            // The second column is at index 1 and the fourth column is at index 3
            if (nu_i >= row[1] && nu_i <= row[3]) {
              n = 2 * i + 3;
              break; // Exit the loop once a matching row is found
            }
          }

          return n; // Will be null if no matching row is found
        }

        //#################################################################################
        //#################################################################################

        // change number of tetrahedra ////////////////////////////////////////////////////

        ebID('buttNumOfTetMinus').addEventListener('click', function () {
          if (n > 3) {
            n = n - 2;
            document.body.dispatchEvent(nChanged);
            // document.body.dispatchEvent(nuiChanged);
          }
        });
        ebID('buttNumOfTetPlus').addEventListener('click', function () {
          if (n < 27) {
            n = n + 2;
            document.body.dispatchEvent(nChanged);
            // document.body.dispatchEvent(nuiChanged);
          }
        });


        // show corner/midpoint paths /////////////////////////////////////////////////////

        var showMid = false;

        //#################################################################################
        //#################################################################################



        var nChanged = new Event('nChanged'); // triggered by plus/minus buttons
        var energyChanged = new Event('energyChanged'); // triggered by plus/minus buttons
        var plotClicked = new Event('plotClicked'); // triggered by clicking on the energy plot

        // document.body.addEventListener('nuiChanged', function (e) {
        //   nuSlider = new Slider('nuSlider', nu_min, nu_max, nu_opt, '&nu;    ', 0, ' ');
        //   ebID('nuSlider').addEventListener('sliderChange', function (e) {
        //     nu_i = parseInt(nuSlider.getValue());
        //      document.body.dispatchEvent(nChanged);
        //     refresh = true;
        //   });

        // }, false);

        /////////////////////////nui changed////////////////////////////

        /////////////////////////n  changed////////////////////////////


        document.body.addEventListener('nChanged', function (e) {
          ebID('infoNumOfTet').innerHTML = n;

          n_to_nui(n)
          // modifying the slider and its limits when n is changed 

          nu_i = nu_opt;
          init_parameters(nu_i)
          data_t0(nu_i);


          //document.body.dispatchEvent(nuiChanged);




          midline.dispose();
          meshDispose(rulings);
          midlineInit();




          if (showMid) {
            meshDispose(tubeMid);
            meshDispose(golf);
            createTube(tubeMid, 2, 0.5 * 3, yellow);
          }

          updateTetrahedra(k, hl);



          refresh = true;
        }, false);


        document.body.addEventListener('plotClicked', function (e) {
          ebID('infoNumOfTet').innerHTML = n;

          n = nui_to_n(nu_i)
          // modifying the slider and its limits when n is changed 

          //nu_i = nu_opt;
          init_parameters(nu_i)
          data_t0(nu_i);


          //document.body.dispatchEvent(nuiChanged);




          midline.dispose();
          meshDispose(rulings);
          midlineInit();




          if (showMid) {
            meshDispose(tubeMid);
            meshDispose(golf);
            createTube(tubeMid, 2, 0.5 * 3, yellow);
          }

          updateTetrahedra(k, hl);



          refresh = true;
        }, false);

        // toggle tetrahedra //////////////////////////////////////////////////////////////

        var tetToggled = new Event('tetToggled'); // triggered by tetTogStar
        document.body.addEventListener('tetToggled', function (e) { refresh = true; }, false);

        var tetTogStar = new TetTogStar('tetTogStar', nMax, tetToggled);

        // play controller ////////////////////////////////////////////////////////////////

        var svg = ebID('playSVG');
        var pt = svg.createSVGPoint();
        var dragging = false;
        var clockRing = ebID('clockRing');
        clockRing.addEventListener('mousedown', startDragMouse, false);
        clockRing.addEventListener('touchstart', startDragTouch, false);
        window.addEventListener('mousemove', dragMouse, false);
        window.addEventListener('touchmove', dragTouch, false);
        window.addEventListener('mouseup', stopDrag, false);
        window.addEventListener('touchend', stopDrag, false);
        function startDragMouse(ev) {
          dragging = true;
          if (play) { playIt() };
          dragMouse(ev);
          clockRing.style.opacity = 1;
        }
        function startDragTouch(ev) {
          dragging = true;
          if (play) { playIt() };
          dragTouch(ev);
          clockRing.style.opacity = 1;
        }
        function dragMouse(ev) {
          if (dragging) {
            pt.x = ev.clientX;
            pt.y = ev.clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateTetrahedra(k, hl);
            refresh = true;
          }
        }
        function dragTouch(ev) {
          if (dragging) {
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateTetrahedra(k, hl);
            refresh = true;
          }
        }
        function stopDrag() {
          dragging = false;
          clockRing.style.opacity = '';
        }
        function playIt() {
          play = !play;
          if (!play) {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 13 0');
          }
          else {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 -2 10 -2 -10 2 -10 2 10 7 10 7 -10 -7 -10');
          }
        };
        ebID('buttPlayPause').addEventListener('click', playIt, false);
        document.addEventListener('keydown', function (e) { if (e.keyCode == '32') playIt(); }); // space key play

        // speed control //////////////////////////////////////////////////////////////////

        var speedSlider = new Slider('speedSlider', 4, 100, 20, 'speed ', 0, '%');
        ebID('speedSlider').addEventListener('sliderChange', function () {
          speedy = speedSlider.getValue() / 2000 / n ** .2;
        });

        // change width/length ////////////////////////////////////////////////////////////

        var hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 20, 'width', 0, '%');
        ebID('hingeLengthSlider').addEventListener('sliderChange', function () {
          hl = hingeLengthSlider.getValue() / 100.0;
          if (!play) updateTetrahedra(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })


        ///  modifying sliders during the guiding tour 
        ebID('speedSlider').addEventListener('tourSpeed', function () {
          speedSlider = new Slider('speedSlider', 4, 100, 40, 'speed ', 0, '%');
          speedy = 40 / 2000 / n ** .2;
        });

        ebID('speedSlider').addEventListener('tourSpeedBack', function () {
          speedSlider = new Slider('speedSlider', 4, 100, 20, 'speed ', 0, '%');
          speedy = 20 / 2000 / n ** .2;
        });


        ebID('hingeLengthSlider').addEventListener('tourWidth', function () {
          hl = 0.4;
          hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 40, 'width', 0, '%');

          if (!play) updateTetrahedra(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })
        ebID('hingeLengthSlider').addEventListener('tourWidthBack', function () {
          hl = 0.2;
          hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 20, 'width', 0, '%');

          if (!play) updateTetrahedra(k, hl);
          // if (showCorn) {
          //   meshDispose(tubeCorn);
          //   createTube(tubeCorn,1,hl,white);
          // }
          refresh = true;
        })

        ////////////////////////////////////////////////////////////////

        // toggle full screen /////////////////////////////////////////////////////////////

        // var ortho = false;
        var fullScreen = false;
        ebID('buttFullScreen').addEventListener('click', function () {
          fullScreen = !fullScreen;
          buttonSwitchColor(ebID('buttFullScreen'), fullScreen);
          toggleFullScreen();
          // ortho = !ortho;
          // if ( ortho ) camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
          // else camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
        });


        // show axis/plane ////////////////////////////////////////////////////////////////





        var showUnit = false;
        ebID('buttShowUnit').addEventListener('click', function () {
          showUnit = !showUnit;
          buttonSwitchColor(ebID('buttShowUnit'), showUnit);





          refresh = true;
        });

        // align to plane/axis ////////////////////////////////////////////////////////////
        var alignPlane = false;
        ebID('buttAlignPlane').addEventListener('click', function () {
          alignPlane = !alignPlane;
          //  buttonSwitchColor(ebID('buttAlignPlane' ), alignPlane);
          camera.alpha = Math.PI;
          camera.beta = Math.PI / 2;
          if (!play) k = 0;
          refresh = true;
        });
        var alignAxis = false;
        ebID('buttAlignAxis').addEventListener('click', function () {
          alignAxis = !alignAxis;
          // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = Math.PI;
          camera.beta = 0;
          if (!play) k = 0;
          refresh = true;
        });

        // changing the camera angle during the tour 
        ebID('renderCanvas').addEventListener('tourCamera', function (event) {
          console.log("enetered rotate camera")
           // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = event.detail.alpha;
          camera.beta = event.detail.beta;
          if (!play) k = 0;
          refresh = true;
        });

        // change surface colors //////////////////////////////////////////////////////////

        var previousColorScheme = colorScheme;
        buttonSwitchColor(ebID('buttColor' + colorScheme), true);

        for (var i = 1; i < maxColor + 1; i++) {
          (function (i) {
            ebID('buttColor' + i).addEventListener('click', function () {
              previousColorScheme = colorScheme;
              colorScheme = i;
              document.body.dispatchEvent(colorChanged);
            });
          }(i));
        }

        var colorChanged = new Event('colorChanged'); // triggered by plus/minus buttons

        document.body.addEventListener('colorChanged', function (e) {
          buttonSwitchColor(ebID('buttColor' + previousColorScheme), false);
          buttonSwitchColor(ebID('buttColor' + colorScheme), true);
          if (!play) updateTetrahedra(k, hl);
          refresh = true;
        }, false);


        var tubeMid = [];
        ebID('buttShowMid').addEventListener('click', function () {
          showMid = !showMid;
          buttonSwitchColor(ebID('buttShowMid'), showMid);
          if (showMid) createTube(tubeMid, 1, 0.5 * 3, yellow);
          else {
            meshDispose(tubeMid);
            meshDispose(golf);
          }
          refresh = true;
        });
        ///////////////////////////////////////////////////////////////////////////////////

        camera.attachControl(canvas, false);

        function refreshScene() { refresh = true; } // to prevent freezing of the render window after long inactivity
        setInterval(refreshScene, 1000);





        //#############################################################
        //#############################################################
        scene.registerBeforeRender(function () {
          if (play || k == 0) {
            updateTetrahedra(k, hl);
            // move clock hand
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(k));
            dot.setAttribute('cy', -40 * Math.cos(k));
            if (play) k += speedy;
          }
        });
        //#############################################################
        //#############################################################


        // the canvas/window resize event handler
        window.addEventListener('resize', function () { engine.resize(); refresh = true; });

        function rend() {
          scene.render();
        }

        var customRender = function () {
          if (refresh || play ||
            Math.abs(camera.inertialRadiusOffset) > 0 ||
            Math.abs(camera.inertialAlphaOffset) > 0 ||
            Math.abs(camera.inertialBetaOffset) > 0) {
            scene.render();
          }
          if (refresh) refresh = false;
        }
        engine.stopRenderLoop(); // Stop the automatic PG rendering
        rend(); // Render the first frame.
        engine.runRenderLoop(customRender); //start main render loop

        //document.body.addEventListener('nuiChanged', function () { console.log("updated value of nu index is " +  parseInt(nuSlider.getValue()))});







        yData = Array.from(energy).concat();
        xData = linspace(8.095, 85.4, yData.length);

 

        var showEnergy = false;
        var showKappa = false;
        var showEversionPath = false;


        var renderCanvasK = document.getElementById('renderCanvasK');

        var contentKWidth = contentK.clientWidth;
        var x_legend = [];

        var legendCount = 13;
        var legendSpacing = contentKWidth / (legendCount + 1);

        for (var i = 1; i <= legendCount; i++) {
          x_legend.push(i * legendSpacing);
        };


        function deleteDataset(chart, label) {
          var datasetIndex = chart.data.datasets.findIndex(dataset => dataset.label === label);

          if (datasetIndex !== -1) {
            chart.data.datasets.splice(datasetIndex, 1);
            chart.update();
          };
        };

        function pushDataset(chart, ind) {
          var markerCoordinate = { x: xData[ind], y: yData[ind] };


          chart.data.datasets.push({
            label: 'Marker',
            data: [markerCoordinate],
            backgroundColor: 'rgba(0, 0, 0, 0)', // Set the background color to transparent
            borderColor: 'red',
            borderWidth: 3,
            pointRadius: 5,  // Adjust this to change the size of the marker
            pointStyle: 'circle', // optional: to ensure the marker is a circle
            order: 1
          });
          var tempx = [xData[0], xData[ind] + 1.185];
          var tempy = [yData[ind], yData[ind]];
          chart.data.datasets.push({
            label: 'cursor1',
            data: tempx.map((value, index) => ({ x: value, y: tempy[index] })),
            backgroundColor: "rgba(0, 0, 0, 0)",
            borderColor: "rgba(255, 255, 255, 0.5)", // White color with transparency
            borderWidth: 1,
            borderDash: [5, 5], // Dotted line pattern (5px line, 5px space)
            pointRadius: 0,
            order: 2

          });
          var tempx = [xData[ind], xData[ind]];
          var tempy = [35, yData[ind] + 11.5];
          chart.data.datasets.push({
            label: 'cursor2',
            data: tempx.map((value, index) => ({ x: value, y: tempy[index] })),
            backgroundColor: "rgba(0, 0, 0, 0)",
            borderColor: "rgba(255, 255, 255, 0.5)", // White color with transparency
            borderWidth: 1,
            borderDash: [5, 5], // Dotted line pattern (5px line, 5px space)
            pointRadius: 0,
            order: 2

          });

          chart.update();
        };


         createChart = function(nu_i) {
          if (chart != null) {
            chart.destroy();
          }

          var ctx = document.getElementById('renderCanvasE').getContext('2d', { willReadFrequently: true });

          chart = new Chart(ctx, {
            type: "line",
            data: {
              datasets: [],
            },
            options: {

              maintainAspectRatio: false, // Disable aspect ratio to fit the canvas
              scales: {
                x: {
                  min: xData[0] - .4,
                  max: xData[xData.length - 1],
                  type: "linear",
                  position: "bottom",
                  ticks: {
                    font: {
                      size: 16 // Increase the font size for x-axis ticks
                    },
                    color: 'white',  // this will change the color of the y-axis labels to white
                  },
                  grid: {
                    color: 'rgba(255, 255, 255, 0.1)',  // this will change the color of y-axis grid lines to white (with 10% opacity)
                    borderColor: 'white',  // this will change the color of the y-axis itself to white
                    //   drawOnChartArea: false,  // Extend gridlines across the entire canvas
                    borderDash: [2, 4],  // Optional: Customize the appearance of the gridlines

                  },
                  title: {
                    display: true,
                    text: "dimensionless torsion",//'\u03BD', // HTML to display x^2
                    color: "white",//
                    font: {
                      size: 14 // Increase the font size for x-axis ticks
                    },
                  }
                },
                y: {
                  min: 35,
                  max: 115,
                  type: "linear",
                  position: "left",
                  ticks: {
                    font: {
                      size: 16
                    },
                    color: 'white',
                    stepSize: 40,
                  },
                  grid: {
                    color: 'rgba(255, 255, 255, 0.1)',  // this will change the color of y-axis grid lines to white (with 10% opacity)
                    borderColor: 'white',  // this will change the color of the y-axis itself to white
                    borderDash: [1, 4],  // Optional: Customize the appearance of the gridlines

                  },
                  title: {
                    display: true,
                    text: "dimensionless energy", // HTML to display x^2
                    color: "white",//
                    font: {
                      size: 14 // Increase the font size for x-axis ticks
                    },
                  }
                },

              },
              plugins: {
                legend: {
                  display: true,

                  labels: {
                    filter: function (item, chart) {
                      // Return false to hide the legend item
                      if (item.text === 'Marker') return false;
                      if (item.text === 'cursor1') return false;
                      if (item.text === 'cursor2') return false;
                      // Return true to show the legend item
                      return true;
                    },
                    color: 'white', // Set the legend labels' color to white
                    font: {
                      size: 16 // Increase the font size for legend labels
                    }
                  },
                  //   align: 'start'  // Spread out legend labels to occupy the same space as the horizontal axis

                }
              }
            },
          });
          let ind_marker = nu_i - 1;
          var markerCoordinate = { x: xData[ind_marker], y: yData[ind_marker] };


          chart.data.datasets.push({
            label: 'Marker',
            data: [markerCoordinate],
            backgroundColor: 'rgba(0, 0, 0, 0)', // Set the background color to transparent
            borderColor: 'red',
            borderWidth: 3,
            pointRadius: 5,  // Adjust this to change the size of the marker
            pointStyle: 'circle' // optional: to ensure the marker is a circle
          });

          var tempx = [xData[0], xData[ind_marker] + 1.185];
          var tempy = [yData[ind_marker], yData[ind_marker]];
          chart.data.datasets.push({
            label: 'cursor1',
            data: tempx.map((value, index) => ({ x: value, y: tempy[index] })),
            backgroundColor: "rgba(0, 0, 0, 0)",
            borderColor: "rgba(255, 255, 255, 0.5)", // White color with transparency
            borderWidth: 1,
            borderDash: [5, 5], // Dotted line pattern (5px line, 5px space)
            pointRadius: 0,
            order: 2

          });
          var tempx = [xData[ind_marker], xData[ind_marker]];
          var tempy = [35, yData[ind_marker] + 11.5];
          chart.data.datasets.push({
            label: 'cursor2',
            data: tempx.map((value, index) => ({ x: value, y: tempy[index] })),
            backgroundColor: "rgba(0, 0, 0, 0)",
            borderColor: "rgba(255, 255, 255, 0.5)", // White color with transparency
            borderWidth: 1,
            borderDash: [5, 5], // Dotted line pattern (5px line, 5px space)
            pointRadius: 0,
            order: 2

          });

          var ind = ind_energy.concat();
          var legendBoxWidths = [20, 20, 20, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300]; // Example: Define desired x-coordinates for each legend label

          for (var i = 0; i < 13; i++) {
            var startIndex = ind[i][1];
            var endIndex = ind[i + 1][1];

            var slicedXData = xData.slice(startIndex, endIndex + 1);
            var slicedYData = yData.slice(startIndex, endIndex + 1);

            var color = `rgb(${colEnergy[i].join(", ")})`;
            chart.data.datasets.push({
              label: "n=" + (2 * i + 3),
              data: slicedXData.map((value, index) => ({ x: value, y: slicedYData[index] })),
              backgroundColor: "rgba(0, 0, 0, 0)",
              borderColor: color,
              borderWidth: 2,
              pointRadius: 0,
              //pointStyle: 'circle' // optional: to ensure the marker is a circle
              order: 2,

              options: {
                // ...
                plugins: {
                  title: {
                    display: true,
                    text: 'curvature of the midline'
                  },
                  legend: {
                    display: true,
                    labels: {
                      color: 'white',
                      font: {
                        size: 16
                      },
                      desiredX: x_legend[i], // Assign the x-location of the legend label from x_legend array

                    },
                    align: 'start' // Spread out legend labels to occupy the same space as the horizontal axis
                  }
                }
              }
            });
          }
          // Set the boxWidth property for the current legend label
          chart.update(); // Update the chart to display the added datasets
        }

        function destroyChart(chart) {
          if (chart) {  // Check if chart is defined
            chart.destroy();
            chart = null;
          }
        }


        ebID('buttShowEnergy').addEventListener('click', function () {
          showEnergy = !showEnergy;
          buttonSwitchColor(ebID('buttShowEnergy'), showEnergy);

          if (showEnergy == false) {
            contentK.style.top = '0%';
            contentE.style.height = '0%';
            destroyChart(chart);  // Destroy the chart when showEnergy is false
          } else {
            contentE.style.height = '25%';
            //nu_i = parseInt(nuSlider.getValue());
            createChart(nu_i);
            document.body.addEventListener('nuiChanged', function () {
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);

              if (showKappa == true) {
                contentK.style.top = '25%';
              }

            });
            document.body.dispatchEvent(energyChanged);

            document.body.addEventListener('nChanged', function (e) {
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);
            });
            document.body.addEventListener('plotClicked', function (e) {
              deleteDataset(chart, 'Marker');
              deleteDataset(chart, 'cursor1');
              deleteDataset(chart, 'cursor2');

              pushDataset(chart, nu_i - 1);
            });

            // Create the chart when showEnergy is true
          }
        });
        // energy changed during the tour

        ebID('buttShowEnergy').addEventListener('tourEnergy', function (event) {

          nu_i = event.detail.nu_i;
          showEnergy = true;
          // console.log(`index inside the show energy: ${nu_i} `);
          contentE.style.height = '25%';
          //nu_i = parseInt(nuSlider.getValue());
          createChart(nu_i);
          document.body.addEventListener('nuiChanged', function () {
            deleteDataset(chart, 'Marker');
            deleteDataset(chart, 'cursor1');
            deleteDataset(chart, 'cursor2');

            pushDataset(chart, nu_i - 1);

            if (showKappa == true) {
              contentK.style.top = '25%';
            }

          });
          document.body.dispatchEvent(energyChanged);

          document.body.addEventListener('nChanged', function (e) {
            deleteDataset(chart, 'Marker');
            deleteDataset(chart, 'cursor1');
            deleteDataset(chart, 'cursor2');

            pushDataset(chart, nu_i - 1);
          });
          document.body.addEventListener('plotClicked', function (e) {
            deleteDataset(chart, 'Marker');
            deleteDataset(chart, 'cursor1');
            deleteDataset(chart, 'cursor2');

            pushDataset(chart, nu_i - 1);
          });

          nui_to_n(nu_i);
          //document.body.dispatchEvent(plotClicked);
          document.body.dispatchEvent(plotClicked);


          refresh = true;
          // Create the chart when showEnergy is true

        });


        ////////////////////////////////////////////////////////////////
        // create the chart for curvature 
        ////////////////////////////////////////////////////////////////

        var chartK = null;


        function createchartK(kappa) {
          if (chartK != null) {
            chartK.destroy();
          }
          var kmin = Math.min(...kappa0);
          var kmax = Math.max(...kappa0);

          if (kmax > Math.abs(kmin)) {
            var klim = Math.abs(kmax);
          }
          else {
            var klim = Math.abs(kmin);
          }

          var yticklocation = linspace(-1 * klim, klim, 4);

          var yData = Array.from(kappa).concat();
          //var xData = linspace(1, yData.length, yData.length);
          var xData = linspace(0, 1, yData.length);


          var ctxK = document.getElementById('renderCanvasK').getContext('2d', { willReadFrequently: true });
          chartK = new Chart(ctxK, {
            type: "line",
            data: {
              datasets: [],

            },
            options: {

              responsive: true,
              animation: false, // Disable animation
              maintainAspectRatio: false, // Disable aspect ratio to fit the canvas
              scales: {
                x: {
                  min: 0,
                  max: 1,
                  type: "linear",
                  position: "bottom",
                  ticks: {
                    color: 'white',
                    font: {
                      size: 16 // Increase the font size for x-axis ticks
                    },  // this will change the color of the y-axis labels to white
                  },
                  grid: {
                    color: 'rgba(255, 255, 255, 0.1)',  // this will change the color of y-axis grid lines to white (with 10% opacity)
                    borderColor: 'white',  // this will change the color of the y-axis itself to white
                    //   drawOnchartKArea: false,  // Extend gridlines across the entire canvas
                    borderDash: [2, 4],  // Optional: Customize the appearance of the gridlines

                  },
                  title: {
                    display: true,
                    text: 'arclength', // HTML to display x^2
                    color: "white", //
                    font: {
                      size: 14 // Increase the font size for x-axis ticks
                    },
                  }
                },
                y: {
                  min: -1 * klim - 2,
                  max: klim + 2,
                  type: "linear",
                  position: "left",
                  ticks: {
                    maxTicksLimit: 4,  // Maximum number of ticks on the y-axis
                    color: 'white',  // this will change the color of the y-axis labels to white
                    font: {
                      size: 16 // Increase the font size for x-axis ticks
                    },
                    //           callback: function(value, index) {
                    //   if (yticklocation.includes(value)) {
                    //     return value;
                    //   } else {
                    //     return '';
                    //   }
                    // }
                  },
                  grid: {
                    color: 'rgba(255, 255, 255, 0.1)',  // this will change the color of y-axis grid lines to white (with 10% opacity)
                    borderColor: 'white',  // this will change the color of the y-axis itself to white
                    borderDash: [1, 4],  // Optional: Customize the appearance of the gridlines

                  },
                  title: {
                    display: true,
                    text: "curvature of midline", // HTML to display x^2
                    color: "white", font: {
                      size: 14
                    }, //
                  }
                },

              },
              plugins: {
                legend: {
                  display: false,

                  labels: {

                    color: 'white', // Set the legend labels' color to white
                    font: {
                      size: 16 // Increase the font size for legend labels
                    }
                  },

                },

              }
            },
          });

          var indices = [];
          var temp = Math.round(N / (1 * n));
          for (var i = 1; i < n + 1; i++) {
            indices[i - 1] = (i - 1) * temp + Math.round(temp / 2);
          }
          chartK.data.datasets.push({
            label: 'markers',
            data: indices.map((index) => ({ x: xData[index], y: yData[index] })),
            backgroundColor: 'red',
            borderColor: 'red',
            pointBackgroundColor: 'red',
            pointBorderColor: 'red',
            pointRadius: 6,
            pointHoverRadius: 6,
            type: 'scatter',
            order: 1,
          });

          for (var i = 0; i < yData.length - 1; i++) {
            chartK.data.datasets.push({
              label: 'curvature of the midline',
              data: [
                { x: xData[i], y: yData[i] },
                { x: xData[i + 1], y: yData[i + 1] },
              ],
              backgroundColor: 'rgba(0, 0, 0, 0)',
              borderColor: jetK(i),
              borderWidth: 3,
              pointRadius: 0,
              order: 1,
            });
          }

          chartK.update(); // Update the chartK to display the added datasets

        }


        // creating the plot for paths
        //var curve = paths(n, hingeLength, type, ind);




        ebID('buttShowKappa').addEventListener('click', function () {
          showKappa = !showKappa;
          buttonSwitchColor(ebID('buttShowKappa'), showKappa);

          if (showKappa == false) {
            contentK.style.height = '0%';
            destroyChart(chartK);  // Destroy the chartK when showKappa is false
          } if (showKappa == true) {
            if (showEnergy == true) {
              contentK.style.top = '25%';
            }
            contentK.style.height = '22%';
            //  createchartK(kappa);

            document.body.addEventListener('energyChanged', function () {
              contentK.style.top = '25%';
            });


            if (showEnergy === false) {
              contentK.style.top = '0%';
            }





            // Create the chartK when showKappa is true
          }
        });




        var getIndexFromLinspace = function (x) {
          let start = xData[0];
          let end = xData[xData.length - 1];
          let length = yData.length;

          if (x < start || x > end || length <= 1) {
            return -1; // x is out of the range or invalid length
          }

          var step = (end - start) / (length - 1);
          var index = Math.round((x - start) / step);

          if (index < 0 || index >= length) {
            return -1; // The calculated index is out of bounds
          }

          return index;
        }
        document.getElementById('renderCanvasE').addEventListener('click', function (evt) {
          const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, false);

          if (points.length) {
            const firstPoint = points[0];
            const datasetIndex = firstPoint.datasetIndex;
            const index = firstPoint.index;

            // Access the data point as an object
            const dataPoint = chart.data.datasets[datasetIndex].data[index];

            // Store the x value in nu_i
            nu_i = getIndexFromLinspace(dataPoint.x); // Assuming nu_i should hold the x value of the clicked point
             // updaign the value of n
            nui_to_n(nu_i)
            document.body.dispatchEvent(plotClicked);


            refresh = true;
          }
        });
 


        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////


        return scene;
      }

      var scene = createScene(); // call the createScene function

      // Create a custom event
      var openColorPickerEvent = new Event('openColorPicker');


      document.getElementById('backgroundButton').addEventListener('openColorPicker', function () {
        // Trigger the color picker
        document.getElementById('colorPicker').click();
      });

      // Keep the existing 'click' event listener as well
      document.getElementById('backgroundButton').addEventListener('click', function () {
        document.getElementById('colorPicker').click();
      });


      document.getElementById('colorPicker').addEventListener('input', function () {
        // Get the color value from the color picker
        var colorVal = this.value;

        // Convert hex color to RGB
        var r = parseInt(colorVal.substr(1, 2), 16) / 255;
        var g = parseInt(colorVal.substr(3, 2), 16) / 255;
        var b = parseInt(colorVal.substr(5, 2), 16) / 255;

        // Update the scene's background color
        scene.clearColor = new BABYLON.Color3(r, g, b);
      });


    });


    const tour = new Shepherd.Tour({
      defaultStepOptions: {
        cancelIcon: {
          enabled: true
        },
        classes: 'shepherd-theme-arrows',
        scrollTo: true
      }
    });

    // Function to simulate a click
    function simulateClick(elementId) {
      const element = document.getElementById(elementId);
      if (element) {
        var clickEvent = new MouseEvent("click", {
          "view": window,
          "bubbles": true,
          "cancelable": false
        });
        element.dispatchEvent(clickEvent);

      }

    }

    function moveCursorToElement(elementId, callback) {
      const cursor = document.getElementById('animatedCursor');
      const element = document.getElementById(elementId);

      if (element) {
        const elementRect = element.getBoundingClientRect();
        const cursorX = elementRect.left + elementRect.width / 2;
        const cursorY = elementRect.top + elementRect.height / 2;

        cursor.style.left = cursorX + 'px';
        cursor.style.top = cursorY + 'px';

        setTimeout(() => {
          callback();
        }, 1000); // Adjust the timeout to match the duration of the CSS transition
      }
    }

    const svg = document.querySelector('svg'); // Adjust selector as needed
    const svgRect = svg.getBoundingClientRect();

    function getCircleCenterPosition(circleId) {
      const circle = document.getElementById(circleId);
      const cx = parseInt(circle.getAttribute('cx'));
      const cy = parseInt(circle.getAttribute('cy'));

      // Adjust by the SVG container's position
      const x = svgRect.left + cx + window.scrollX;
      const y = svgRect.top + cy + window.scrollY;

      return { x, y };
    }

    function moveCursorToPosition(x, y, callback) {
      const cursor = document.getElementById('animatedCursor');

      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';

      setTimeout(() => {
        callback();
      }, 1000); // Adjust the timeout as needed
    }
 
    function simulateClickAtCoordinates(elementId, x, y) {
  const element = document.getElementById(elementId);
  if (element) {
    const clickEvent = new MouseEvent("click", {
      clientX: x,
      clientY: y,
      bubbles: true,
      cancelable: true
    });
    element.dispatchEvent(clickEvent);
  }
}
 



    tour.addStep({
      title: 'Increase Twists',
      text: `This button increases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetPlus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetPlus', () => {
            //simulateClick('buttNumOfTetPlus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    tour.addStep({
      title: 'Increase Twists',
      text: `This button increases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetPlus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetPlus', () => {
            simulateClick('buttNumOfTetPlus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    tour.addStep({
      title: 'Increase Twists',
      text: `This button increases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetPlus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetPlus', () => {
            simulateClick('buttNumOfTetPlus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    // Similar setup for 'buttNumOfTetMinus'

    tour.addStep({
      title: 'decrease Twists',
      text: `This button decreases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetMinus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetMinus', () => {
            simulateClick('buttNumOfTetMinus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    tour.addStep({
      title: 'decrease Twists',
      text: `This button decreases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetMinus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetMinus', () => {
            simulateClick('buttNumOfTetMinus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    // Similar setup for 'buttNumOfTetMinus'

    tour.addStep({
      title: 'play',
      text: `This button plays the everting motion.`,
      attachTo: {
        element: '#playPausePoly',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('playPausePoly', () => {
            simulateClick('playPausePoly');
            setTimeout(() => tour.next(), 500); // Proceed to next step after the action
          });
        }
      }
    });

    // tour.addStep({
    //   title: 'play',
    //   text: `click again to pause the everting motion.`,
    //   attachTo: {
    //     element: '#playPausePoly',
    //     on: 'bottom'
    //   },
    //   when: {
    //     show: function() {
    //       moveCursorToElement('playPausePoly', () => {
    //         simulateClick('playPausePoly');
    //         setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
    //       });
    //     }
    //   }
    // });


    /// adding step for speed slider 

    var tourSliderMin;
    var tourSliderMax;

    function calculateSliderClickPosition(sliderId, value) {
      const slider = document.getElementById(sliderId);
      const sliderRange = [tourSliderMin, tourSliderMax]; // Min and max values of the slider
      const sliderWidth = 200; // Width of the slider in pixels

      // Calculate the proportional position of the value
      const valueRatio = (value - sliderRange[0]) / (sliderRange[1] - sliderRange[0]);
      // Adjusting positionX to start from the left edge of the slider
      const positionX = (valueRatio * sliderWidth); // Subtract 100 because the viewbox starts at -100

      return positionX;
    }



    function simulateClickOnSlider(sliderId, value, callback) {
      const positionX = calculateSliderClickPosition(sliderId, value);
      const slider = document.getElementById(sliderId);

      if (slider) {
        const sliderRect = slider.getBoundingClientRect();
        const cursor = document.getElementById('animatedCursor');

        // Calculate the exact position for the cursor
        const clickPositionX = sliderRect.left + positionX + window.scrollX;
        const clickPositionY = sliderRect.top + sliderRect.height / 2 + window.scrollY;

        // Move the cursor to the calculated position
        cursor.style.left = clickPositionX + 'px';
        cursor.style.top = clickPositionY + 'px';

        // Simulate the click after a short delay to allow for cursor movement
        setTimeout(() => {
          var clickEvent = new MouseEvent("click", {
            clientX: clickPositionX,
            clientY: clickPositionY,
            bubbles: true,
            cancelable: true
          });
          slider.dispatchEvent(clickEvent);

          // Execute the callback function after the click
          if (typeof callback === "function") {
            setTimeout(callback, 1000); // Adjust timeout as needed
          }
        }, 1000); // Adjust the timeout for cursor movement
      }
    }


    var tourSpeed = new Event('tourSpeed');
    var tourSpeedBack = new Event('tourSpeedBack');

    tourSliderMin = 4;
    tourSliderMax = 100;
    tour.addStep({
      title: 'Adjust Speed',
      text: 'Click on this slider to change the speed of eversion.',
      attachTo: {
        element: '#speedSlider',
        on: 'bottom'
      },
      when: {
        show: function () {
          simulateClickOnSlider('speedSlider', 40, () => {
            tour.next();
          });
          document.getElementById('speedSlider').dispatchEvent(tourSpeed);
        }
      }
    });

    // tour.addStep({
    //   title: 'Adjust Speed back',
    //   text: 'Click on this slider to change the speed of eversion.',
    //   attachTo: {
    //     element: '#speedSlider',
    //     on: 'bottom'
    //   },
    //   when: {
    //     show: function () {
    //       simulateClickOnSlider('speedSlider', 20, () => {
    //         tour.next();
    //       });
    //       document.getElementById('speedSlider').dispatchEvent(tourSpeedBack);
    //     }
    //   }
    // });
    // width 
    var tourWidth = new Event('tourWidth');
    var tourWidthBack = new Event('tourWidthBack');
    tourSliderMin = 0;
    tourSliderMax = 100;
    tour.addStep({
      title: 'Adjust band width',
      text: 'Click on this slider to change the width of the band.',
      attachTo: {
        element: '#hingeLengthSlider',
        on: 'bottom'
      },
      when: {
        show: function () {
          simulateClickOnSlider('hingeLengthSlider', 40, () => {
            tour.next();
          });
          document.getElementById('hingeLengthSlider').dispatchEvent(tourWidth);
        }
      }
    });
    tour.addStep({
      title: 'Adjust band width',
      text: 'Click on this slider to change the width of the band.',
      attachTo: {
        element: '#hingeLengthSlider',
        on: 'bottom'
      },
      when: {
        show: function () {
          simulateClickOnSlider('hingeLengthSlider', 20, () => {
            tour.next();
          });
          document.getElementById('hingeLengthSlider').dispatchEvent(tourWidthBack);
        }
      }
    });


    // view angle 

    tour.addStep({
      title: 'view axis',
      text: `view along the axis of symmetry.`,
      attachTo: {
        element: '#buttAlignAxis',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttAlignAxis', () => {
            simulateClick('buttAlignAxis');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });
    tour.addStep({
      title: 'view axis',
      text: `view along the plane of symmetry.`,
      attachTo: {
        element: '#buttAlignPlane',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttAlignPlane', () => {
            simulateClick('buttAlignPlane');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    // change the camera angle to default
     alpha  =  6.185710546084945;
     beta = 1.0989063024750556;
    var tourCamera =   new CustomEvent('tourCamera', { detail: { alpha: alpha,beta: beta} });
    tour.addStep({
      title: 'view angle',
      text: `hold the left click and move the mouse to rotate the band.`,
      attachTo: {
        element: '#renderCanvas',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('renderCanvas', () => {
             
            setTimeout(() => tour.next(), 3000); // Proceed to next step after the action
          });
          document.getElementById('renderCanvas').dispatchEvent(tourCamera);
        }
      }
    });

    // eversion path 
    tour.addStep({
      title: 'view eversion path',
      text: `path of eversion of a point on the midline.`,
      attachTo: {
        element: '#buttShowMid',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowMid', () => {
            simulateClick('buttShowMid');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });
    tour.addStep({
      title: 'view unit',
      text: `1/n th of the band with n half twists.`,
      attachTo: {
        element: '#buttShowUnit',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowUnit', () => {
            simulateClick('buttShowUnit');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });
    tour.addStep({
      title: 'view unit',
      text: `1/n th of the band with n half twists.`,
      attachTo: {
        element: '#buttShowUnit',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowUnit', () => {
            simulateClick('buttShowUnit');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    tour.addStep({
      title: 'view energy plot',
      text: `plot of the bending energy of stable bands versus the torsion of the midline of the band.`,
      attachTo: {
        element: '#buttShowEnergy',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowEnergy', () => {
            simulateClick('buttShowEnergy');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });


 


    function moveCursorToPosition(x, y, callback) {
      const cursor = document.getElementById('animatedCursor');
      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';

      setTimeout(() => {
        if (typeof callback === "function") {
          callback();
        }
      }, 1000); // Adjust the delay as needed
    }


    //// clicking on the chart completed



    tour.addStep({
      title: 'view curvature',
      text: `curvature of the midline during eversion.`,
      attachTo: {
        element: '#buttShowKappa',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttShowKappa', () => {
            simulateClick('buttShowKappa');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });





    const desiredIndex = 5; // Replace with the desired index

    var chart;
    var showEnergy;

    var index = 50;
    yData = Array.from(energy).concat();
    xData = linspace(8.095, 85.4, yData.length);
    var mouseX = xData[index];
    var mouseY = yData[index];

    tour.addStep({
      title: 'change band',
      text: 'click on the plot to see the band corresponding to the given torsion of the midline.',
      attachTo: {
        element: '#renderCanvasE',
        on: 'bottom'
      },
      when: {
        show: function () {

          // Store the x value in nu_i
          nu_i = 50; // Assuming nu_i should hold the x value of the clicked point
          
            // Example coordinates, adjust as needed
      const x = mouseX; // X coordinate on the canvas
      const y = mouseY; // Y coordinate on the canvas

      moveCursorToElement('renderCanvasE', () => {
        simulateClickAtCoordinates('renderCanvasE', x, y);
            setTimeout(() => tour.next(), 3000); // Proceed to next step after the action
          });
 
    
          // var tourEnergy = new CustomEvent('tourEnergy', { detail: { nu_i: nu_i } });
          // document.getElementById('buttShowEnergy').dispatchEvent(tourEnergy);

        }
      }
    });
 
    // second click on the energy plot 
    tour.addStep({
     // title: 'change band',
     title: 'click on the plot',
     // text: 'click on the plot to see the band corresponding to the given torsion of the midline.',
      attachTo: {
        element: '#renderCanvasE',
        on: 'bottom'
      },
      when: {
        show: function () {

          // Store the x value in nu_i
          nu_i = 10; // Assuming nu_i should hold the x value of the clicked point
          
            // Example coordinates, adjust as needed
      const x = 200; // X coordinate on the canvas
      const y = 150; // Y coordinate on the canvas

      moveCursorToElement('renderCanvasE', () => {
        const cursor = document.getElementById('animatedCursor');
      if (cursor) {
        cursor.style.display = 'none'; // Hide the cursor
      }
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
 
    
          var tourEnergy = new CustomEvent('tourEnergy', { detail: { nu_i: nu_i } });
          document.getElementById('buttShowEnergy').dispatchEvent(tourEnergy);

        }
      }
    });
    // second click on the energy plot 
    tour.addStep({
      title: 'click on the plot',
         attachTo: {
        element: '#renderCanvasE',
        on: 'bottom'
      },
      when: {
        show: function () {
         
          // Store the x value in nu_i
          nu_i = 250; // Assuming nu_i should hold the x value of the clicked point
          
            // Example coordinates, adjust as needed
      const x = 200; // X coordinate on the canvas
      const y = 150; // Y coordinate on the canvas

      moveCursorToElement('renderCanvasE', () => {
        const cursor = document.getElementById('animatedCursor');
      if (cursor) {
        cursor.style.display = 'none'; // Hide the cursor
      }
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
 
    
          var tourEnergy = new CustomEvent('tourEnergy', { detail: { nu_i: nu_i } });
          document.getElementById('buttShowEnergy').dispatchEvent(tourEnergy);

        }
      }
    });
    
// going back to the optimal bands 

tour.addStep({
      text: 'clicking here will give the optimal bands',
      //text: `This button decreases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetMinus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetMinus', () => {
            simulateClick('buttNumOfTetMinus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });

    tour.addStep({
      title: 'clicking here will give the optimal bands',
     // text: `This button decreases the number of half twists of the optimal band.`,
      attachTo: {
        element: '#buttNumOfTetMinus',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttNumOfTetMinus', () => {
            simulateClick('buttNumOfTetMinus');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });






    // colors 
    tour.addStep({
      title: 'view colors',
      text: `change color of the band.`,
      attachTo: {
        element: '#buttColor2',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttColor2', () => {
            simulateClick('buttColor2');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });
    // colors 
    tour.addStep({
      title: 'view colors',
      text: `change color of the band.`,
      attachTo: {
        element: '#buttColor1',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('buttColor1', () => {
            simulateClick('buttColor1');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });




    // Shepherd tour step
    tour.addStep({
      title: 'View Colors',
      text: 'Change the background color using the picker on the top-left.',
      attachTo: {
        element: '#backgroundButton',
        on: 'bottom'
      },
      when: {
        show: function () {
          moveCursorToElement('backgroundButton', () => {
            simulateClick('backgroundButton');
            setTimeout(() => tour.next(), 2000); // Proceed to next step after the action
          });
        }
      }
    });









    tour.on('complete', function () {
      const cursor = document.getElementById('animatedCursor');
      if (cursor) {
        cursor.style.display = 'none'; // Hide the cursor
      }
    });

    // for continuing hovering

    const leftBar = document.querySelector('.leftbar');
    const rightBar = document.querySelector('.rightbar');

    tour.on('start', function () {
      leftBar.classList.add('simulated-hover');
      rightBar.classList.add('simulated-hover');
    });

    tour.on('complete', function () {
      leftBar.classList.remove('simulated-hover');
      rightBar.classList.remove('simulated-hover');
    });

    tour.on('cancel', function () {
      leftBar.classList.remove('simulated-hover');
      rightBar.classList.remove('simulated-hover');
    });


    // Start the tour

    // ...add more steps for other buttons...

    // Start the tour
    var showTour = true;
    window.startTour = function () {
      const cursor = document.getElementById('animatedCursor');
      if (cursor) {
        cursor.style.display = 'block'; // Show the cursor
      }
      tour.start();

      if(showTour==false){
        tour.cancel();
      }


    }


    // document.addEventListener('DOMContentLoaded', function () {
    //   // Ensure startTour is defined
     
    //     window.startTour();
       
    // });
    document.addEventListener('DOMContentLoaded', function () {
  // Show the modal
  document.getElementById('tourModal').style.display = 'block';
});

// Start tour when "Start Tour" button is clicked
document.getElementById('startTourBtn').addEventListener('click', function() {
  window.startTour();
  document.getElementById('tourModal').style.display = 'none'; // Hide modal
});

// Close modal when "No Thanks" button is clicked
document.getElementById('dismissTourBtn').addEventListener('click', function() {
  document.getElementById('tourModal').style.display = 'none'; // Hide modal
});

// document.addEventListener('keydown', function(event) {
//   if (event.key === 'c' || event.key === 'C') {
//     // Stop the tour
//     if (tour.isActive()) {
//       tour.cancel(); // or tour.complete();
//     }

//     // Hide the cursor
//     const cursor = document.getElementById('animatedCursor');
//     if (cursor) {
//       cursor.style.display = 'none';
//     }
//   }
// });




  </script>

</body>

</html>
